<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Playground</title>

  <!-- ✅ 关键：防止“打开先跳一下”——先隐藏页面，等滚动就位再显示 -->
  <style>
    body { visibility: hidden; }
  </style>

  <!-- ✅ 关键：滚动控制（默认=顶部；只有 ?from=method 才到第二屏；且不会“闪一下又回顶部”） -->
  <script>
    (function () {
      if ("scrollRestoration" in history) history.scrollRestoration = "manual";

      // ✅ 本次页面生命周期只结算一次，避免重复 settle 导致跳回顶部
      let settled = false;

      function showBody() {
        document.body.style.visibility = "visible";
      }

      function scrollToTopInstant() {
        const prev = document.documentElement.style.scrollBehavior;
        document.documentElement.style.scrollBehavior = "auto";
        window.scrollTo(0, 0);
        document.documentElement.style.scrollBehavior = prev;
      }

      // 返回 true 表示成功滚到了 choose（元素存在）
      function scrollToChooseInstant() {
        const el = document.getElementById("choose");
        if (!el) return false;
        const prev = document.documentElement.style.scrollBehavior;
        document.documentElement.style.scrollBehavior = "auto";
        el.scrollIntoView({ behavior: "auto", block: "start" });
        document.documentElement.style.scrollBehavior = prev;
        return true;
      }

      // 清掉 ?from=method（保留其它 query），同时清掉 hash
      function clearFromMethodFlag() {
        const url = new URL(location.href);
        url.searchParams.delete("from");
        url.hash = "";
        const qs = url.searchParams.toString();
        history.replaceState(null, "", url.pathname + (qs ? "?" + qs : ""));
      }

      function settleScroll() {
        if (settled) return;

        const sp = new URLSearchParams(location.search);
        const fromMethod = sp.get("from") === "method";

        if (fromMethod) {
          // 只有滚成功了才算结算完成（避免第一次太早，choose 还没出来）
          const ok = scrollToChooseInstant();
          if (ok) {
            clearFromMethodFlag();
            settled = true;
          }
        } else {
          scrollToTopInstant();
          settled = true;
        }
      }

      // 尽量早地先定位一次
      settleScroll();

      // DOM 完整后再定位一次，最后再显示
      window.addEventListener("DOMContentLoaded", () => {
        requestAnimationFrame(() => {
          settleScroll();
          showBody();
        });
      });

      // pageshow：只在 bfcache 恢复时允许重新结算
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) settled = false;
        requestAnimationFrame(() => {
          settleScroll();
          showBody();
        });
      });
    })();
  </script>

  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Helvetica Neue", Arial, "PingFang SC";
      color:#111;
      background:#fff;
      overflow-x:hidden;
    }
    a{ color:inherit; text-decoration:none; }

    :root{
      --edge: clamp(18px, 4vmin, 44px);
      --top:  clamp(14px, 2.6vmin, 28px);

      /* 右上角：稍微小一点（边距不变） */
      --cornerSize: clamp(156px, 20vmin, 286px);
      --cornerRadius: clamp(12px, 2.1vmin, 18px);

      --heroBottom: clamp(34px, 7vmin, 102px);
    }

    /* ======= Cover (第一屏) ======= */
    .cover{
      position: relative;
      min-height: 100vh;
      min-height: 100svh;
      width: 100%;
      padding: 36px var(--edge);
      overflow:hidden;
      background:#fff;
    }

    /* 背景公式层 */
    .bg-formulas{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
    }
    .formula{
      position:absolute;
      font-size:12px;
      line-height:1.35;
      color:#666;
      opacity:0;
      white-space:pre;
      transform: translateZ(0);
      max-width: min(620px, calc(100vw - 160px));
      word-break: break-word;
    }
    @media (max-width: 980px){
      .formula{ max-width: min(460px, calc(100vw - 90px)); }
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.75; }
      50% { opacity: 0.9; }
    }
    .formula.show{
      opacity:1;
      transition: opacity 120ms linear;
      animation: breathe 6s ease-in-out infinite;
    }
    .formula.fade{
      animation: none;
      opacity:0;
      transition: opacity 220ms ease;
    }

    /* 左上角新模块（位置/边距保持不变） */
    .leftui{
      position:absolute;
      left:var(--edge);
      top:var(--top);
      z-index:2;
      max-width: min(520px, calc(100vw - var(--edge) * 2 - var(--cornerSize)));
    }

    /* 小标题图 */
    .leftui .mini-hero{
      width: clamp(180px, 21.5vmin, 320px);
      height: auto;
      display:block;
    }

    /* 四个词 */
    .leftui .words{
      margin-top: 12px;
      font-size: 17px;
      line-height: 1.42;
      color:#111;
      opacity: .95;
    }
    .leftui .words div{ margin: 3px 0; }

    /* Try now：更强调 */
    .trylink{
      display:inline-flex;
      align-items:center;
      gap:12px;
      margin-top: 14px;
      font-size: 22px;
      font-weight: 650;
      color:#111;
      cursor:pointer;
      user-select:none;
    }
    .trylink .arrow{
      display:inline-block;
      font-size: 32px;
      line-height: 1;
      animation: blinkArrow 900ms steps(2, end) infinite;
      transform: translateY(2px);
    }
    @keyframes blinkArrow{
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0.12; }
    }

    /* 右上角轮播 */
    .corner{
      position:absolute;
      right:var(--edge);
      top:var(--top);
      width: var(--cornerSize);
      aspect-ratio: 1 / 1;
      border-radius: var(--cornerRadius);
      overflow:hidden;
      background:#fff;
      z-index:2;
    }
    .corner img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      transform: translateZ(0);
    }

    .hero{
      position:absolute;
      left:var(--edge);
      right:var(--edge);
      bottom: var(--heroBottom);
      display:flex;
      justify-content:center;
      z-index:2;
    }
    .hero img{
      width: 100%;
      height: auto;
      display:block;
      max-width: none;
      max-height: clamp(320px, 38vmin, 680px);
      object-fit: contain;
    }

    /* ======= 第二屏 ======= */
    .wrap{
      width:min(1200px, calc(100% - 48px));
      margin:0 auto;
    }

    .section{ padding: 56px 0 84px; background:#fff; }

    @media (min-height: 900px){
      .section{ padding-top: 76px; }
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:44px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; gap:34px; }
    }

    .item{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    .thumb{
      width:100%;
      aspect-ratio: 3 / 4.7;
      border-radius: 54px;
      border: 1.6px solid rgba(0,0,0,.25);
      overflow:hidden;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .thumb img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      background:#fff;
    }

    .note{
      font-size: 12px;
      line-height: 1.35;
      color:#111;
      text-align:center;
      max-width: 44ch;
    }

    footer{
      border-top: 1px solid rgba(0,0,0,.08);
      padding: 18px 0 26px;
      color: #888;
      font-size: 12px;
      background:#fff;
      text-align: center;
    }

    /* ✅ 第二屏底部提示（在版权上面，居中、更浅灰） */
    .helpnote{
      margin: 0 0 8px;
      font-size: 11px;
      line-height: 1.35;
      color: #b7b7b7;
    }
  </style>
</head>

<body>
  <section class="cover" id="cover">
    <div class="bg-formulas" id="bgFormulas" aria-hidden="true"></div>

    <div class="leftui" id="leftUI">
      <img class="mini-hero" src="assets/hero/title.png" alt="Font(X)=Y">
      <div class="words" aria-label="keywords">
        <div>Function</div>
        <div>Parameter</div>
        <div>System</div>
        <div>Form</div>
      </div>

      <!-- ✅ 不使用 #choose，避免 hash 影响刷新 -->
      <a class="trylink" href="javascript:void(0)" id="tryBtn" aria-label="Try now - jump to methods">
        <span class="arrow" aria-hidden="true">→</span>
        <span>Try now</span>
      </a>
    </div>

    <div class="corner" id="cornerBox">
      <img id="cornerImg" alt="cover-rotating">
    </div>

    <div class="hero" id="heroBox">
      <img src="assets/hero/title.png" alt="Font(X)=Y">
    </div>
  </section>

  <section id="choose" class="section">
    <div class="wrap">
      <div class="grid">
        <a class="item" href="draw.html">
          <div class="thumb">
            <img src="assets/home/blocks.png" alt="Font building blocks">
          </div>
          <div class="note">
            Experiment with building modular glyphs using mathematical grids and geometric patterns
          </div>
        </a>

        <a class="item" href="path.html">
          <div class="thumb">
            <img src="assets/home/path.png" alt="Font Path Method">
          </div>
          <div class="note">
            Experiment with building modular glyphs using mathematical grids and geometric patterns
          </div>
        </a>

        <a class="item" href="texture.html">
          <div class="thumb">
            <img src="assets/home/texture.png" alt="Font Texture Method">
          </div>
          <div class="note">
            Experiment with building modular glyphs using mathematical grids and geometric patterns
          </div>
        </a>
      </div>
    </div>
  </section>

  <footer>
    <div class="wrap">
      <div class="helpnote">If something isn’t working, try opening and refreshing on a desktop browser.</div>
      © <span id="y"></span> Font Playground
    </div>
  </footer>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    const tryBtn = document.getElementById("tryBtn");
    tryBtn.addEventListener("click", (e) => {
      e.preventDefault();
      document.getElementById("choose")?.scrollIntoView({ behavior: "smooth", block: "start" });
    });

    /* 右上角轮播：1秒切换 */
    const coverImgs = [
      "assets/cover/01-07.png",
      "assets/cover/01-08.png",
      "assets/cover/01-09.png",
      "assets/cover/01-10.png",
      "assets/cover/01-11.png",
      "assets/cover/01-12.png",
      "assets/cover/01-13.png",
      "assets/cover/01-14.png",
      "assets/cover/01-15.png",
      "assets/cover/01-16.png",
      "assets/cover/01-17.png",
      "assets/cover/01-18.png"
    ];
    coverImgs.forEach(src => { const im = new Image(); im.src = src; });

    const cornerImgEl = document.getElementById("cornerImg");
    let ci = 0;
    cornerImgEl.src = coverImgs[0];
    setInterval(() => {
      ci = (ci + 1) % coverImgs.length;
      cornerImgEl.src = coverImgs[ci];
    }, 1000);

    /* ===== 背景公式 ===== */
    const BASE_FORMULAS = [
      "x + y = y + x",
      "a(x + b) = ax + ab",
      "x² - a² = (x + a)(x - a)",
      "(x ± a)² = x² ± 2ax + a²",
      "x = [-b ± √(b² - 4ac)]/(2a)",
      "y = kx + b",
      "y = ax² + bx + c",
      "sin(x + y) = sinx cosy + cosx siny",
      "sin²x + cos²x = 1",
      "a^x × a^y = a^(x + y)",
      "log_a x = log_c x / log_c a",
      "(x^n)' = n x^(n - 1)",
      "∫x^n dx = x^(n + 1)/(n + 1) + C",
      "∫[a,b]x^n dx = b^(n + 1)/(n + 1) - a^(n + 1)/(n + 1)",
      "y = sinx",
      "y = cosx",
      "y = ln x",
      "y = e^x",
      "ax + by = c",
      "(x - a)² + (y - b)² = r²",
      "dy/dx = (dy/dt)/(dx/dt)",
      "∫sinx dx = -cosx + C",
      "∫cosx dx = sinx + C",
      "x^m × x^n = x^(m + n)",
      "(xy)^n = x^n y^n",

      "y = ax³ + bx² + cx + d + (e x)/(f + x²)",
      "y = sin(kx + φ) + cos(mx - θ) + tan(nx)",
      "x = [ -b ± √(b² - 4ac + 8de - 2fg) ] / (2a + 3h)",
      "y = a e^(kx) + b ln(cx + d) + c √(ex² + fx + g)",
      "y = (x² - 3x + 2)(2x³ + 5x - 7)/(x + 4)(x² - 1)",
      "(x - a)² + (y - b)² + (z - c)² + 2(x - a)(y - b) = r²",
      "y = k1 x + b1 + k2 x² + b2 √x + k3/(x + b3)",
      "sin(2x + 3)cos(4x - 5) = [sin(6x - 2) + sin(-2x + 8)]/2",
      "log_a(bx² + cx + d) - log_a(ex + f) = log_a[(bx² + cx + d)/(ex + f)]",
      "y = a tan²x + b secx + c cotx + d cscx",
      "x³ + 2x²y + 3xy² + 4y³ + 5x + 6y + 7 = 0",
      "y = √(ax² + bx + c) + (dx + e)/(fx² + gx + h)",
      "(x² + y²)² = 4axy + 2bx² - 3cy² + dx - ey",
      "y = a sin²(kx) + b cos²(mx) + c sin(kx)cos(mx)",
      "(x - a)(x - b)(x - c) + (y - d)(y - e)(y - f) = gxy",
      "y = (ax³ + bx² + cx + d)^(1/3) + (ex² + fx + g)^(2/3)",
      "y = e^(kx + m)sin(nx + p) + ln(qx² + rx + s) + √(tx + u)"
    ];

    const FORCE_3LINES = [
      "y = asin(kx + φ)cos(mx - θ) + be^(px + q)ln(rx² + sx + t) + sqrt(ux³ + vx + w)/(zx + y) + ctan(dx)",
      "log_m(nx³ + px² + qx + r) - log_m(sx + t) + sqrt(ux⁴ + vx³ + wx² + zx + y) = kx + b + a/(cx² + dx + e)",
      "(x - a)(x - b)(x - c)(x - d) + (y - e)(y - f) = hx²y + ixy² + jx + ky + l + m/(nx + py + q) + rx³",
      "∫(ax⁵ + bx⁴ + cx³ + dx² + ex + f)/(gx² + hx + i)dx = (jx⁶)/(6g) + (kx⁵)/(5g) - lln|gx² + hx + i| + C + mx",
      "y = sqrt(ax⁴ + bx³ + cx² + dx + e) + (fx + g)/(hx² + ix + j) + ksin(lx + m) + ncos(px + q) + rtan(sx) + t(x² + y²)(x - y)(x + y) + a*(x³ + y³) = bx²y² + cxy + d + e/(fx² + gy + h) + isin(jx + ky)",
      "y = ae^(kx + m)ln(nx² + rx + s) + bsqrt(tx³ + ux² + vx + w) + (zx + y)/(px² + qx + r) + ccot(dx + e)",
      "log_a(bx⁴ + cx³ + dx² + ex + f) - log_a(gx + h) = ix² + jx + k + l/(mx² + nx + p) + qsin(rx + s)",
      "∫(sin(kx)cos(mx) + e^(px)ln(qx + r))dx = -cos((k+m)x)/(2(k+m)) + e^(px)ln(qx + r)/p - s/(p²(qx + r)) + C",
      "y = (ax³ + bx² + cx + d)^(2/3) + (ex² + fx + g)/(hx + i) + jsin(kx + l)cos(mx) + ne^(px + q) + sqrt(rx + t)"
    ];

    const FORMULAS = BASE_FORMULAS.concat(FORCE_3LINES);

    const cover = document.getElementById("cover");
    const bg = document.getElementById("bgFormulas");
    const leftUI = document.getElementById("leftUI");
    const cornerBox = document.getElementById("cornerBox");
    const heroBox = document.getElementById("heroBox");

    const MAX_ACTIVE = 4;
    const LINE_TRIGGER = 36;

    const TWO_LINE_REFERENCE = "sin(x + y) = sinx cosy + cosx siny";
    const TWO_LINE_LEN = TWO_LINE_REFERENCE.length;

    const active = [];

    const rand = (a, b) => a + Math.random() * (b - a);
    const randi = (a, b) => Math.floor(rand(a, b));
    const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];

    function rectInCover(el){
      const cr = cover.getBoundingClientRect();
      const r = el.getBoundingClientRect();
      return { x: r.left - cr.left, y: r.top - cr.top, w: r.width, h: r.height };
    }
    function inflateRect(rc, pad){
      return { x: rc.x - pad, y: rc.y - pad, w: rc.w + pad*2, h: rc.h + pad*2 };
    }
    function overlaps(a, b){
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }

    function getExcludedRects(){
      const pad = 22;
      const list = [];
      if (leftUI) list.push(inflateRect(rectInCover(leftUI), pad));
      if (cornerBox) list.push(inflateRect(rectInCover(cornerBox), pad));
      if (heroBox) list.push(inflateRect(rectInCover(heroBox), pad));
      return list;
    }

    function getSoftAvoidRect(){
      const cr = cover.getBoundingClientRect();
      const cb = cornerBox.getBoundingClientRect();
      const hb = heroBox.getBoundingClientRect();

      const cornerIn = { x: cb.left - cr.left, y: cb.top - cr.top, w: cb.width, h: cb.height };
      const heroIn   = { x: hb.left - cr.left, y: hb.top - cr.top, w: hb.width, h: hb.height };

      const x0 = Math.max(cornerIn.x - 40, cr.width * 0.55);
      const x1 = cr.width - Math.max(28, cr.width * 0.07);

      const y0 = cornerIn.y + cornerIn.h + 10;
      const y1 = heroIn.y - 10;

      return { x: x0, y: y0, w: Math.max(1, x1 - x0), h: Math.max(1, y1 - y0) };
    }

    function getBottomSoftAvoidRect(){
      const cr = cover.getBoundingClientRect();
      const hb = heroBox.getBoundingClientRect();
      const heroIn = { x: hb.left - cr.left, y: hb.top - cr.top, w: hb.width, h: hb.height };

      const padX = Math.max(24, cr.width * 0.08);
      const up = Math.max(140, cr.height * 0.22);
      const down = 26;

      const x = Math.max(0, heroIn.x - padX);
      const y = Math.max(0, heroIn.y - up);
      const w = Math.min(cr.width, heroIn.w + padX * 2);
      const h = Math.min(cr.height - y, up + heroIn.h + down);

      return { x, y, w, h };
    }

    const sizeCache = new Map();
    function measureFormulaSize(text){
      const cached = sizeCache.get(text);
      if (cached) return cached;

      const tmp = document.createElement("div");
      tmp.className = "formula";
      tmp.style.visibility = "hidden";
      tmp.style.left = "-9999px";
      tmp.style.top = "-9999px";
      tmp.textContent = text;
      bg.appendChild(tmp);
      const r = tmp.getBoundingClientRect();
      bg.removeChild(tmp);

      const size = { w: r.width, h: r.height };
      sizeCache.set(text, size);
      return size;
    }

    function distanceScore(cx, cy){
      if (active.length === 0) return 1e9;

      let bestDist = 1e9;
      let bestY = 1e9;

      for (const a of active){
        const ax = a.rect.x + a.rect.w/2;
        const ay = a.rect.y + a.rect.h/2;
        const d = Math.hypot(cx - ax, cy - ay);
        const dy = Math.abs(cy - ay);
        if (d < bestDist) bestDist = d;
        if (dy < bestY) bestY = dy;
      }
      return bestDist + bestY * 0.35;
    }

    const breakChars = new Set([" ", "+", "-", "=", ")", "(", "/", "*", "×", "±", "−", "·", ","]);
    function findBreakIndex(s, from, near){
      const window = 18;
      let best = -1;
      let bestScore = 1e9;

      const lo = Math.max(from + 10, near - window);
      const hi = Math.min(s.length - 10, near + window);

      for (let i = lo; i <= hi; i++){
        const ch = s[i];
        if (!breakChars.has(ch)) continue;

        const cut = (ch === " ") ? i : (i + 1);

        let bias = 0;
        if (ch === " ") bias -= 0.6;
        if (ch === "=") bias -= 0.4;

        const score = Math.abs(cut - near) + bias;

        if (score < bestScore){
          bestScore = score;
          best = cut;
        }
      }
      if (best === -1) best = Math.min(s.length - 10, Math.max(from + 10, near));
      return best;
    }

    function splitIntoLines(raw, lines){
      const s = (raw || "").trim();
      if (lines <= 1) return s;
      if (s.length < 22) return s;

      const target = Math.floor(s.length / lines);
      const cuts = [];
      let start = 0;

      for (let li = 1; li < lines; li++){
        const near = start + target;
        const cut = findBreakIndex(s, start, near);
        cuts.push(cut);
        start = cut;
      }

      const parts = [];
      let prev = 0;
      for (const c of cuts){
        parts.push(s.slice(prev, c).trim());
        prev = c;
      }
      parts.push(s.slice(prev).trim());

      return parts.filter(Boolean).join("\n");
    }

    function formatFormula(raw){
      const s = (raw || "").trim();

      if (FORCE_3LINES.includes(raw)) return splitIntoLines(s, 3);
      if (s.length > TWO_LINE_LEN) return splitIntoLines(s, 2);
      if (s.length <= LINE_TRIGGER) return s;

      if (Math.random() < 0.25) return splitIntoLines(s, 2);
      return s;
    }

    function pickFormulaRaw(){
      const used = new Set(active.map(a => a.raw));
      const pool = FORMULAS.filter(f => !used.has(f));
      return pool.length ? choice(pool) : choice(FORMULAS);
    }

    function findPosition(w, h){
      const cr = cover.getBoundingClientRect();
      const safe = Math.max(32, Math.floor(Math.min(cr.width, cr.height) * 0.06));
      const excluded = getExcludedRects();
      const softRight = getSoftAvoidRect();
      const softBottom = getBottomSoftAvoidRect();

      let best = null;
      let bestScore = -1;

      const tries = 180;
      for (let t = 0; t < tries; t++){
        const x = randi(safe, Math.max(safe + 1, Math.floor(cr.width  - w - safe)));
        const y = randi(safe, Math.max(safe + 1, Math.floor(cr.height - h - safe)));
        const cand = { x, y, w, h };

        if (excluded.some(er => overlaps(cand, er))) continue;
        if (active.some(a => overlaps(cand, inflateRect(a.rect, 14)))) continue;

        const inSoftRight = overlaps(cand, softRight);
        const inSoftBottom = overlaps(cand, softBottom);

        let penalty = 1.0;
        if (inSoftRight) penalty *= 0.55;
        if (inSoftBottom) penalty *= 0.45;

        const cx = x + w/2;
        const cy = y + h/2;
        const score = distanceScore(cx, cy) * penalty;

        if (score > bestScore){
          bestScore = score;
          best = { x, y };
        }
      }
      return best || { x: safe, y: safe };
    }

    function spawnOne(){
      if (active.length >= MAX_ACTIVE) return;

      const raw = pickFormulaRaw();
      const text = formatFormula(raw);

      const size = measureFormulaSize(text);
      const pos = findPosition(size.w, size.h);

      const el = document.createElement("div");
      el.className = "formula";
      el.style.left = pos.x + "px";
      el.style.top  = pos.y + "px";
      bg.appendChild(el);

      const info = { raw, text, el, rect: { x: pos.x, y: pos.y, w: size.w, h: size.h } };
      active.push(info);

      requestAnimationFrame(() => el.classList.add("show"));

      let i = 0;
      const speed = rand(16, 32);

      const timer = setInterval(() => {
        i++;
        el.textContent = text.slice(0, i);

        if (i >= text.length){
          clearInterval(timer);

          setTimeout(() => {
            el.classList.add("fade");
            setTimeout(() => {
              const idx = active.indexOf(info);
              if (idx >= 0) active.splice(idx, 1);
              el.remove();
            }, 240);
          }, 1000);
        }
      }, speed);
    }

    let quietUntil = 0;
    let nextQuietAt = Date.now() + randi(30000, 45000);
    function canSpawn() { return Date.now() > quietUntil; }

    function schedule(){
      const delay = (active.length === 0)
        ? randi(140, 700)
        : randi(320, 1900);

      setTimeout(() => {
        const now = Date.now();

        if (now >= nextQuietAt) {
          quietUntil = now + randi(3000, 5000);
          nextQuietAt = now + randi(30000, 45000);
        }

        if (!canSpawn()) {
          schedule();
          return;
        }

        const want = randi(1, 3);
        const toAdd = Math.min(MAX_ACTIVE - active.length, want, 2);
        for (let k = 0; k < toAdd; k++) spawnOne();

        schedule();
      }, delay);
    }

    window.addEventListener("resize", () => {
      active.splice(0).forEach(a => a.el?.remove());
      sizeCache.clear();
    });

    schedule();
  </script>
</body>
</html>
