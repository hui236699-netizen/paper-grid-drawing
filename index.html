<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Playground</title>

  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Helvetica Neue", Arial, "PingFang SC";
      color:#111;
      background:#fff;
      overflow-x:hidden;
    }
    a{ color:inherit; text-decoration:none; }

    /* ======= Cover (第一屏) ======= */
    :root{
      --edge: 44px;
      --top: 28px;
    }
    @media (max-width: 980px){
      :root{ --edge: 18px; --top: 14px; }
    }

    .cover{
      position: relative;
      min-height: 100vh;
      width: 100%;
      padding: 36px var(--edge);
      background:#fff;
      overflow:hidden; /* 让背景公式不会跑出第一屏 */
    }

    /* ✅ 背景公式层（最底层） */
    .bg-formulas{
      position:absolute;
      inset:0;
      z-index:0;
      pointer-events:none;
    }
    .formula{
      position:absolute;
      font-size:12px;           /* 跟左上角同一字号 */
      line-height:1.35;
      color:#111;
      opacity:0;
      white-space:pre;
      transform: translateZ(0);
    }
    .formula.show{ opacity:1; transition: opacity 120ms linear; }
    .formula.fade{ opacity:0; transition: opacity 180ms ease; }

    .cursor{
      display:inline-block;
      margin-left:2px;
      width:8px;
      animation: blink 0.8s step-end infinite;
    }
    @keyframes blink { 50% { opacity: 0; } }

    .topnote{
      position:absolute;
      left:var(--edge);
      top:var(--top);
      font-size:12px;
      line-height:1.35;
      color:#111;
      max-width: 360px;
      opacity:.9;
      z-index:2;
    }

    .corner{
      position:absolute;
      right:var(--edge);
      top:var(--top);
      width: 260px;
      aspect-ratio: 1 / 1;
      border-radius: 16px;
      overflow:hidden;
      background:#fff;
      z-index:2;
    }
    .corner img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      transform: translateZ(0);
    }
    @media (max-width: 980px){
      .corner{ width: 160px; border-radius: 14px; }
    }

    .hero{
      position:absolute;
      left:var(--edge);
      right:var(--edge);
      bottom: 42px;
      display:flex;
      justify-content:center;
      z-index:2;
    }
    @media (max-width: 980px){
      .hero{ bottom: 28px; }
    }
    .hero img{
      width: 100%;
      height: auto;
      display:block;
      max-width: none; /* 关键：吃满左右边距 */
    }

    /* ======= 下面原来那页：三张卡片进三个网页（保留） ======= */
    .wrap{
      width:min(1200px, calc(100% - 48px));
      margin:0 auto;
    }

    .section{ padding: 56px 0 84px; }
    .section h2{
      margin:0 0 6px;
      font-size: 24px;
      letter-spacing:-.01em;
    }
    .section .sub{
      margin:0 0 18px;
      color:#666;
      font-size: 13px;
      line-height:1.6;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:44px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; gap:34px; }
    }

    .item{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    .thumb{
      width:100%;
      aspect-ratio: 3 / 4.7;
      border-radius: 54px;
      border: 1.6px solid rgba(0,0,0,.25);
      overflow:hidden;
      background:#fff;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .thumb img{
      width:100%;
      height:100%;
      object-fit: cover;
      display:block;
      background:#fff;
    }

    .note{
      font-size: 12px;
      line-height: 1.35;
      color:#111;
      text-align:center;
      max-width: 44ch;
    }

    footer{
      border-top: 1px solid rgba(0,0,0,.08);
      padding: 18px 0 26px;
      color: #888;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <!-- ======= 第一屏：封面 ======= -->
  <section class="cover" id="cover">
    <!-- ✅ 背景公式最底层容器 -->
    <div class="bg-formulas" id="bgFormulas" aria-hidden="true"></div>

    <div class="topnote" id="topnote">
      Experiment with building modular glyphs using<br/>
      mathematical grids and geometric patterns
    </div>

    <div class="corner" id="cornerBox">
      <img id="cornerImg" alt="cover-rotating">
    </div>

    <!-- 你的 Font(X)=Y 大图（请确保路径存在） -->
    <div class="hero" id="heroBox">
      <img src="assets/hero/title.png" alt="Font(X)=Y">
    </div>
  </section>

  <!-- ======= 下面原来那页：三张卡片进三个网页（保留） ======= -->
  <section id="choose" class="section">
    <div class="wrap">
      <h2>Choose a Method</h2>
      <p class="sub">Click an image to enter.</p>

      <div class="grid">
        <a class="item" href="draw.html">
          <div class="thumb">
            <img src="assets/home/blocks.png" alt="Font building blocks">
          </div>
          <div class="note">
            Experiment with building modular glyphs using mathematical grids and geometric patterns
          </div>
        </a>

        <a class="item" href="path.html">
          <div class="thumb">
            <img src="assets/home/path.png" alt="Font Path Method">
          </div>
          <div class="note">
            Experiment with building modular glyphs using mathematical grids and geometric patterns
          </div>
        </a>

        <a class="item" href="texture.html">
          <div class="thumb">
            <img src="assets/home/texture.png" alt="Font Texture Method">
          </div>
          <div class="note">
            Experiment with building modular glyphs using mathematical grids and geometric patterns
          </div>
        </a>
      </div>
    </div>
  </section>

  <footer>
    <div class="wrap">© <span id="y"></span> Font Playground</div>
  </footer>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    /* ==========================
       右上角轮播：12张，每1秒切换
       ========================== */
    const coverImgs = [
      "assets/cover/01-07.png",
      "assets/cover/01-08.png",
      "assets/cover/01-09.png",
      "assets/cover/01-10.png",
      "assets/cover/01-11.png",
      "assets/cover/01-12.png",
      "assets/cover/01-13.png",
      "assets/cover/01-14.png",
      "assets/cover/01-15.png",
      "assets/cover/01-16.png",
      "assets/cover/01-17.png",
      "assets/cover/01-18.png"
    ];
    coverImgs.forEach(src => { const im = new Image(); im.src = src; });

    const cornerImgEl = document.getElementById("cornerImg");
    let ci = 0;
    cornerImgEl.src = coverImgs[0];
    setInterval(() => {
      ci = (ci + 1) % coverImgs.length;
      cornerImgEl.src = coverImgs[ci];
    }, 1000);

    /* ==========================================
       背景公式（最底层）：随机 1~3 条，打字出现
       - 打完停 0.5s
       - 淡出消失
       - 随机时间出现
       - 不会出现在 左上/右上/底部大图 的区域下面
       ========================================== */
    const FORMULAS = [
      "x + y = y + x",
      "a(x + b) = ax + ab",
      "x² - a² = (x + a)(x - a)",
      "(x ± a)² = x² ± 2ax + a²",
      "x = [-b ± √(b² - 4ac)]/(2a)",
      "y = kx + b",
      "y = ax² + bx + c",
      "sin(x + y) = sinx cosy + cosx siny",
      "sin²x + cos²x = 1",
      "a^x × a^y = a^(x + y)",
      "log_a x = log_c x / log_c a",
      "(x^n)' = n x^(n - 1)",
      "∫x^n dx = x^(n + 1)/(n + 1) + C",
      "∫[a,b]x^n dx = b^(n + 1)/(n + 1) - a^(n + 1)/(n + 1)",
      "y = sinx",
      "y = cosx",
      "y = ln x",
      "y = e^x",
      "ax + by = c",
      "(x - a)² + (y - b)² = r²",
      "dy/dx = (dy/dt)/(dx/dt)",
      "∫sinx dx = -cosx + C",
      "∫cosx dx = sinx + C",
      "x^m × x^n = x^(m + n)",
      "(xy)^n = x^n y^n"
    ];

    const cover = document.getElementById("cover");
    const bg = document.getElementById("bgFormulas");
    const topnote = document.getElementById("topnote");
    const cornerBox = document.getElementById("cornerBox");
    const heroBox = document.getElementById("heroBox");

    const active = []; // {text, el, rect:{x,y,w,h}}

    const rand = (a, b) => a + Math.random() * (b - a);
    const randi = (a, b) => Math.floor(rand(a, b));
    const choice = (arr) => arr[Math.floor(Math.random() * arr.length)];

    function rectInCover(el){
      const cr = cover.getBoundingClientRect();
      const r = el.getBoundingClientRect();
      return {
        x: r.left - cr.left,
        y: r.top  - cr.top,
        w: r.width,
        h: r.height
      };
    }

    function inflateRect(rc, pad){
      return { x: rc.x - pad, y: rc.y - pad, w: rc.w + pad*2, h: rc.h + pad*2 };
    }

    function overlaps(a, b){
      return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y);
    }

    function getExcludedRects(){
      const pad = 18; // ✅ 避让余量
      const list = [];
      if (topnote) list.push(inflateRect(rectInCover(topnote), pad));
      if (cornerBox) list.push(inflateRect(rectInCover(cornerBox), pad));
      if (heroBox) list.push(inflateRect(rectInCover(heroBox), pad));
      return list;
    }

    // 先用隐藏元素测量最终宽高（用于找不重叠的位置）
    function measureFormulaSize(text){
      const tmp = document.createElement("div");
      tmp.className = "formula";
      tmp.style.visibility = "hidden";
      tmp.style.left = "-9999px";
      tmp.style.top = "-9999px";
      tmp.textContent = text;
      bg.appendChild(tmp);
      const r = tmp.getBoundingClientRect();
      bg.removeChild(tmp);
      return { w: r.width, h: r.height };
    }

    function findPosition(w, h){
      const cr = cover.getBoundingClientRect();
      const edgePad = 18;

      const excluded = getExcludedRects();

      for (let t = 0; t < 60; t++){
        const x = randi(edgePad, Math.max(edgePad + 1, Math.floor(cr.width  - w - edgePad)));
        const y = randi(edgePad, Math.max(edgePad + 1, Math.floor(cr.height - h - edgePad)));

        const cand = { x, y, w, h };

        // 不压住三个主要区域
        let bad = excluded.some(er => overlaps(cand, er));
        if (bad) continue;

        // 不和当前公式互相重叠（稍微留点空隙）
        bad = active.some(a => overlaps(cand, inflateRect(a.rect, 10)));
        if (bad) continue;

        return { x, y };
      }

      // 实在找不到：就随便放（但仍然尽量不出界）
      return {
        x: edgePad,
        y: edgePad
      };
    }

    function pickFormulaText(){
      // 同一时间不重复
      const used = new Set(active.map(a => a.text));
      const pool = FORMULAS.filter(f => !used.has(f));
      return pool.length ? choice(pool) : choice(FORMULAS);
    }

    function spawnOne(){
      if (active.length >= 3) return;

      const text = pickFormulaText();
      const size = measureFormulaSize(text);
      const pos = findPosition(size.w, size.h);

      const el = document.createElement("div");
      el.className = "formula";
      el.style.left = pos.x + "px";
      el.style.top  = pos.y + "px";
      bg.appendChild(el);

      // 记录占位（用最终尺寸）
      const info = { text, el, rect: { x: pos.x, y: pos.y, w: size.w, h: size.h } };
      active.push(info);

      // 渐入
      requestAnimationFrame(() => el.classList.add("show"));

      // 打字
      const cursor = document.createElement("span");
      cursor.className = "cursor";
      cursor.textContent = "▍";

      let i = 0;
      const speed = rand(18, 34); // 打字速度
      const timer = setInterval(() => {
        i++;
        const typed = text.slice(0, i);
        el.textContent = typed;
        el.appendChild(cursor);

        if (i >= text.length){
          clearInterval(timer);

          // 打完停 0.5s，再消失
          setTimeout(() => {
            el.textContent = text; // 去掉光标
            el.classList.add("fade");

            setTimeout(() => {
              // 移除
              const idx = active.indexOf(info);
              if (idx >= 0) active.splice(idx, 1);
              if (el.parentNode) el.parentNode.removeChild(el);
            }, 220);
          }, 500);
        }
      }, speed);
    }

    function schedule(){
      // 保证屏幕通常至少有 1 条：如果空了，间隔更短
      const delay = (active.length === 0)
        ? randi(120, 380)
        : randi(320, 1200);

      setTimeout(() => {
        // 每次随机生成 1~3 的目标，但永远不超过 3
        const want = randi(1, 4);
        const toAdd = Math.min(3 - active.length, want);

        for (let k = 0; k < toAdd; k++){
          spawnOne();
        }
        schedule();
      }, delay);
    }

    // 重新排版时：清空重来，避免压住元素
    window.addEventListener("resize", () => {
      active.splice(0).forEach(a => a.el?.remove());
    });

    // 开始
    schedule();
  </script>
</body>
</html>
