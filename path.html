<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Path Method</title>
  <style>
    html, body { margin:0; padding:0; background:#0f1013; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>
<body>
<script>
/* =================== 原始参数（保留你的逻辑） =================== */
let maxAmp = 50;
let t = 0;

let scaleVal = 1.0;
let strokeW = 2;
let amplitude = 10;
let frequency = 1;

// ✅ phase 仍保留在逻辑里（只是删除“滑块操作模块”）
let phase = 0;

let isAnimating = true;
let animationSpeed = 0.02;

let currentFunction = 0;
const functionNames = ["Sin", "Square", "Triangle", "Sawtooth"];

/* =================== 画布与左侧面板 =================== */
const CANVAS_W = 1440;
const CANVAS_H = 900;

// 左侧操作面板宽（保持你之前那种）
let cw = 200;
let ch = 0;

/* =================== 字体（只用于 UI 字） =================== */
const FONT_PATH = "assets/fonts/ABCFavoritHebrewBoldVariable-Trial.ttf";
let uiFont = null;
let fontLoaded = false;

/* =================== 颜色模块（draw.html 同款：SB + Hue） =================== */
let hueVal = 220;
let satVal = 100;
let briVal = 80;
let currentColor;

const PAD = 10;
const COLOR_PANEL_H = 190;

const COLOR_MAIN = {
  x: PAD,
  y: PAD,
  w: cw - 30 - PAD,     // 左边 SB 大方块
  h: COLOR_PANEL_H
};

const COLOR_HUE = {
  x: cw - 30,           // 右边 Hue 条
  y: PAD,
  w: 20,
  h: COLOR_PANEL_H
};

let sbGraphic, hueGraphic;

/* =================== UI：Sliders（删掉 Phase） =================== */
const sliderName = ["Scale", "Stroke Weight", "Amplitude", "Frequency", "Animation Speed"];
let sliders = [];

/* =================== UI：CapButtons（右侧一列，旧排列风格） =================== */
let capButtons = [];
const PHASE_STEP = Math.PI / 6;

function setup() {
  createCanvas(CANVAS_W, CANVAS_H);
  pixelDensity(1);

  // 初始颜色
  updateCurrentColorFromHSV(true);

  // 构建色条与色块
  buildHueGraphic();
  buildSBGraphic();

  // sliders：沿用你原来 map 的纵向分布（大概 400..750）
  for (let i = 0; i < sliders.length; i++) {} // 占位（不用）

  for (let i = 0; i < 5; i++) {
    let y = map(i, 0, 4, 400, 750);
    sliders.push(new Slider(100, y, 150, 40, sliderName[i], 0.5));
  }

  // 右侧按钮：保持“右边一列”的旧习惯
  // ✅ 加了 Randomize / Phase Step（你不要也可以后面删掉两个名字）
  const capNames = [
    "Save",
    "Toggle Animation",
    "Reset",
    "Randomize",
    "Phase Step",
    "Sin",
    "Square",
    "Triangle",
    "Sawtooth"
  ];

  for (let i = 0; i < capNames.length; i++) {
    let y = map(i, 0, capNames.length - 1, 55, 520);
    capButtons.push(new CapButton(width - 120, y, 150, 30, capNames[i]));
  }

  // 默认选中 Sin
  setWaveSelected(0);

  // 异步加载字体（失败也不影响画面）
  tryLoadUIFont();
}

function draw() {
  background(240);

  updateParameters();

  // 画网格（右侧区域：从 cw 开始）
  drawGrid();

  // 中央绘制（保持你原来的 MathA 表达）
  push();
  translate(width / 2, height / 2);
  scale(scaleVal);
  drawMathA();
  pop();

  // 左侧面板背景
  noStroke();
  fill(31, 30, 36);
  rect(0, 0, cw, height);

  // 左侧颜色模块
  drawColorPanel();

  // 右下角函数预览（保留 phase + t）
  drawFunctionDisplay();

  // 动画推进
  if (isAnimating) t += animationSpeed;

  // sliders
  for (let s of sliders) s.run();

  // buttons
  for (let b of capButtons) b.display();
}

/* =================== 网格 =================== */
function drawGrid() {
  stroke(220);
  strokeWeight(1);
  const step = 25;

  // 只画右侧区域
  for (let x = cw; x <= width; x += step) line(x, ch, x, height);
  for (let y = ch; y <= height; y += step) line(cw, y, width, y);
}

/* =================== MathA（保留你的原逻辑） =================== */
function drawMathA() {
  stroke(currentColor);
  strokeWeight(strokeW);
  noFill();

  // Left leg
  drawParametricCurve(-50, 100, 0, -100);

  // Right leg
  drawParametricCurve(50, 100, 0, -100);

  // Crossbar
  drawParametricCurve(-30, 30, 30, 30);
}

function drawParametricCurve(x1, y1, x2, y2) {
  beginShape();
  for (let i = 0; i <= 1.00001; i += 0.01) {
    let x = lerp(x1, x2, i);
    let y = lerp(y1, y2, i);

    // ✅ 完全保留：frequency*dis*TWO_PI + phase + t
    let dis = dist(x, y, x1, y1) * 0.01;
    let offset = applyFunction(frequency * dis * TWO_PI + phase + t) * amplitude;

    let baseLen = dist(x1, y1, x2, y2);
    x += offset * (y2 - y1) / baseLen;
    y -= offset * (x2 - x1) / baseLen;

    if (currentFunction === 0 || currentFunction === 2) curveVertex(x, y);
    else vertex(x, y);
  }
  endShape();
}

function applyFunction(tt) {
  switch (currentFunction) {
    case 0: return sin(tt);
    case 1: return (tt % TWO_PI < PI) ? 1 : -1;
    case 2: return asin(sin(tt)) * 2 / PI;
    case 3: return (tt % TWO_PI) / PI - 1;
    default: return sin(tt);
  }
}

/* =================== 参数更新（无 Phase 滑块，但 phase 仍保留） =================== */
function updateParameters() {
  scaleVal = map(sliders[0].val, 0, 1, 0.5, 3);
  strokeW  = map(sliders[1].val, 0, 1, 0.5, 20);
  amplitude = map(sliders[2].val, 0, 1, 0, maxAmp);
  frequency = map(sliders[3].val, 0, 1, 0.1, 5);
  animationSpeed = map(sliders[4].val, 0, 1, 0, 0.1);
}

/* =================== 右下角函数预览（保留 phase + t） =================== */
function drawFunctionDisplay() {
  const displayWidth = 250;
  const displayHeight = 250;
  const margin = 50;

  stroke(0);
  strokeWeight(3);

  push();
  translate(width - displayWidth / 2 - margin, height - displayHeight / 2 - margin);

  line(-displayWidth / 2, 0, displayWidth / 2, 0);
  line(0, -displayHeight / 2, 0, displayHeight / 2);

  fill(0);
  noStroke();
  textSize(15);

  triangle(-5, -displayHeight / 2, 5, -displayHeight / 2, 0, -displayHeight / 2 - 15);
  triangle(displayWidth / 2 + 15, 0, displayWidth / 2, -5, displayWidth / 2, 5);

  fill(0);
  textAlign(LEFT, TOP);
  text("y", 15, -displayHeight / 2);
  text("x", displayWidth / 2, 25);

  textSize(20);
  textAlign(CENTER, BOTTOM);
  text(functionNames[currentFunction] + " Function", 0, -displayHeight / 2 - 40);
  pop();

  const picCol = color(140);
  stroke(picCol);
  noFill();
  strokeWeight(3);

  beginShape();
  for (let x = 0; x < displayWidth; x += 2) {
    let amp = map(amplitude, 0, maxAmp, 0, displayHeight / 2);
    let y = applyFunction(frequency * x * 0.02 + phase + t) * amp;
    vertex(width - displayWidth - margin + x, height - displayHeight / 2 - margin - y);
  }
  endShape();
}

/* =================== Randomize / Phase Step =================== */
function randomizeParams() {
  // 只随机“造型参数” + phase，不动颜色（避免选色被打断）
  sliders[0].val = random(0.20, 0.75);  // scale
  sliders[1].val = random(0.05, 0.55);  // stroke
  sliders[2].val = random(0.10, 0.85);  // amplitude
  sliders[3].val = random(0.15, 0.70);  // frequency
  sliders[4].val = random(0.05, 0.55);  // speed
  phase = random(0, TWO_PI);
}
function phaseStep() {
  phase = (phase + PHASE_STEP) % TWO_PI;
}

/* =================== 颜色模块（SB + Hue） =================== */
function buildHueGraphic() {
  hueGraphic = createGraphics(COLOR_HUE.w, COLOR_HUE.h);
  hueGraphic.colorMode(HSB, 360, 100, 100);
  hueGraphic.noStroke();
  hueGraphic.loadPixels();

  for (let y = 0; y < COLOR_HUE.h; y++) {
    let h = map(y, 0, COLOR_HUE.h - 1, 0, 360);
    let c = hueGraphic.color(h, 100, 100);
    for (let x = 0; x < COLOR_HUE.w; x++) {
      let idx = (y * COLOR_HUE.w + x) * 4;
      hueGraphic.pixels[idx]     = red(c);
      hueGraphic.pixels[idx + 1] = green(c);
      hueGraphic.pixels[idx + 2] = blue(c);
      hueGraphic.pixels[idx + 3] = 255;
    }
  }
  hueGraphic.updatePixels();
}

function buildSBGraphic() {
  sbGraphic = createGraphics(COLOR_MAIN.w, COLOR_MAIN.h);
  sbGraphic.colorMode(HSB, 360, 100, 100);
  sbGraphic.noStroke();
  sbGraphic.loadPixels();

  for (let y = 0; y < COLOR_MAIN.h; y++) {
    for (let x = 0; x < COLOR_MAIN.w; x++) {
      let sVal = map(x, 0, COLOR_MAIN.w - 1, 0, 100);
      let bVal = map(y, 0, COLOR_MAIN.h - 1, 100, 0);
      let c = sbGraphic.color(hueVal, sVal, bVal);
      let idx = (y * COLOR_MAIN.w + x) * 4;
      sbGraphic.pixels[idx]     = red(c);
      sbGraphic.pixels[idx + 1] = green(c);
      sbGraphic.pixels[idx + 2] = blue(c);
      sbGraphic.pixels[idx + 3] = 255;
    }
  }
  sbGraphic.updatePixels();
}

function updateCurrentColorFromHSV(rebuildSB) {
  push();
  colorMode(HSB, 360, 100, 100);
  currentColor = color(hueVal, satVal, briVal);
  pop();
  if (rebuildSB) buildSBGraphic();
}

function drawColorPanel() {
  imageMode(CORNER);
  image(sbGraphic, COLOR_MAIN.x, COLOR_MAIN.y);
  image(hueGraphic, COLOR_HUE.x, COLOR_HUE.y);

  // hue marker
  let hy = map(hueVal, 0, 360, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
  stroke(255);
  strokeWeight(2);
  line(COLOR_HUE.x - 4, hy, COLOR_HUE.x, hy);
  line(COLOR_HUE.x + COLOR_HUE.w, hy, COLOR_HUE.x + COLOR_HUE.w + 4, hy);

  // current color swatch under panel
  noStroke();
  fill(currentColor);
  rect(PAD, COLOR_MAIN.y + COLOR_MAIN.h + 10, cw - PAD*2, 14, 8);
}

function handleColorClick() {
  // SB
  if (mouseX >= COLOR_MAIN.x && mouseX <= COLOR_MAIN.x + COLOR_MAIN.w &&
      mouseY >= COLOR_MAIN.y && mouseY <= COLOR_MAIN.y + COLOR_MAIN.h) {

    let sx = constrain(mouseX, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
    let sy = constrain(mouseY, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);

    satVal = map(sx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w, 0, 100);
    briVal = map(sy, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h, 100, 0);

    updateCurrentColorFromHSV(false);
    return true;
  }

  // Hue
  if (mouseX >= COLOR_HUE.x && mouseX <= COLOR_HUE.x + COLOR_HUE.w &&
      mouseY >= COLOR_HUE.y && mouseY <= COLOR_HUE.y + COLOR_HUE.h) {

    let yy = constrain(mouseY, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
    hueVal = map(yy, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h, 0, 360);

    updateCurrentColorFromHSV(true);
    return true;
  }

  return false;
}

/* =================== 鼠标交互 =================== */
function mousePressed() {
  // 颜色优先
  if (handleColorClick()) return;

  // sliders
  for (let s of sliders) s.click();

  // buttons
  for (let b of capButtons) {
    if (b.hover()) {
      handleButtonPress(b.str);
      return;
    }
  }
}

function mouseReleased() {
  for (let s of sliders) s.state = false;
}

function handleButtonPress(label) {
  switch (label) {
    case "Save":
      saveCanvas("MathA", "png");
      break;
    case "Toggle Animation":
      isAnimating = !isAnimating;
      break;
    case "Reset":
      resetToDefaults();
      break;
    case "Randomize":
      randomizeParams();
      break;
    case "Phase Step":
      phaseStep();
      break;
    case "Sin":
      setWaveSelected(0);
      break;
    case "Square":
      setWaveSelected(1);
      break;
    case "Triangle":
      setWaveSelected(2);
      break;
    case "Sawtooth":
      setWaveSelected(3);
      break;
  }
}

function setWaveSelected(idx) {
  currentFunction = idx;
  // 让波形按钮显示选中态（在 CapButton 内用 state）
  const mapNameToIdx = {"Sin":0,"Square":1,"Triangle":2,"Sawtooth":3};
  for (let b of capButtons) {
    if (b.str in mapNameToIdx) b.state = (mapNameToIdx[b.str] === idx);
  }
}

function resetToDefaults() {
  currentFunction = 0;
  isAnimating = true;
  t = 0;
  phase = 0;

  for (let s of sliders) {
    s.val = 0.5;
    s.state = false;
  }

  hueVal = 220; satVal = 100; briVal = 80;
  updateCurrentColorFromHSV(true);

  setWaveSelected(0);
}

/* =================== 键盘快捷键（可选，轻量） =================== */
function keyPressed() {
  if (key === 'r' || key === 'R') randomizeParams();
  if (key === 'p' || key === 'P') phaseStep();
  if (key === ' ') isAnimating = !isAnimating;

  if (key === '1') setWaveSelected(0);
  if (key === '2') setWaveSelected(1);
  if (key === '3') setWaveSelected(2);
  if (key === '4') setWaveSelected(3);
}

/* =================== UI Components（保持你原来的手感） =================== */
class CapButton {
  constructor(x, y, w, h, str) {
    this.x = x; this.y = y; this.w = w; this.h = h; this.str = str;
    this.scl = 1;
    this.gray = 150;
    this.state = false;
  }
  hover() {
    return (abs(mouseX - this.x) < this.w / 2 && abs(mouseY - this.y) < this.h / 2);
  }
  display() {
    push();
    rectMode(CENTER);
    translate(this.x, this.y);

    if (this.hover() || this.state) {
      this.gray = lerp(this.gray, 200, 0.12);
      this.scl  = lerp(this.scl, 1.2, 0.12);
    } else {
      this.gray = lerp(this.gray, 150, 0.12);
      this.scl  = lerp(this.scl, 1.0, 0.12);
    }

    noStroke();
    fill(this.gray);

    push();
    scale(this.scl);
    rect(0, 0, this.w, this.h, 40);
    pop();

    fill(255);
    textSize(this.h * 0.5);
    textAlign(CENTER, CENTER);
    useUIFont();
    text(this.str, 0, 0);

    pop();
  }
}

class Slider {
  constructor(x, y, w, h, str, val) {
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.str = str;
    this.val = val;
    this.state = false;
  }
  hover() {
    return (abs(mouseX - this.x) < this.w / 2 && abs(mouseY - this.y) < this.h / 2);
  }
  click() {
    this.state = this.hover();
  }
  drag() {
    if (!this.state) return;
    let v = map(mouseX, this.x - this.w / 2, this.x + this.w / 2, 0, 1);
    v = constrain(v, 0, 1);
    this.val = lerp(this.val, v, 0.12);
  }
  run() {
    this.drag();
    this.display();
  }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);
    noStroke();

    fill(this.hover() ? 150 : 85);
    rect(0, 0, this.w, this.h, 100);

    let vw = map(this.val, 0, 1, 0, this.w);
    fill(this.hover() ? 200 : 140);
    rect(-this.w / 2 + vw / 2, 0, vw, this.h, 100);

    fill(255);
    textSize(this.h * 0.42);
    textAlign(CENTER, CENTER);
    useUIFont();
    text(this.str, 0, 0);
    pop();
  }
}

/* =================== 字体加载（失败不影响） =================== */
function tryLoadUIFont() {
  loadFont(
    FONT_PATH,
    (f) => { uiFont = f; fontLoaded = true; },
    () => { uiFont = null; fontLoaded = false; }
  );
}
function useUIFont() {
  if (fontLoaded && uiFont) textFont(uiFont);
  else textFont("system-ui");
}
</script>
</body>
</html>
