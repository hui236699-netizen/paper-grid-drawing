<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Path Method</title>
  <style>
    html, body { margin:0; padding:0; background:#0f1013; overflow:hidden; }
    canvas { display:block; margin:0 auto; }

    /* 左侧输入框（HTML，不依赖 p5.dom） */
    #glyphInput {
      position: fixed;
      left: 20px;
      top: 240px;          /* 在颜色面板下面 */
      width: 200px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: #fff;
      padding: 0 10px;
      box-sizing: border-box;
      outline: none;
      font-size: 14px;
      z-index: 10;
    }
    #glyphHint {
      position: fixed;
      left: 20px;
      top: 280px;
      width: 200px;
      color: rgba(255,255,255,.65);
      font-size: 12px;
      line-height: 1.3;
      z-index: 10;
      pointer-events: none;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>
<body>

<input id="glyphInput" value="A" maxlength="12" />
<div id="glyphHint">Input a letter / word</div>

<script>
/* =================== 基础设置 =================== */
const CANVAS_W = 1440;
const CANVAS_H = 900;

let cw = 200;      // 左侧栏宽
let ch = 0;

let maxAmp = 50;
let t = 0;

// ✅ Phase 已删除
let scaleVal = 1.0;
let strokeW = 2;
let amplitude = 10;
let frequency = 1;
let isAnimating = true;
let animationSpeed = 0.02;

let currentFunction = 0;
const functionNames = ["Sin", "Square", "Triangle", "Sawtooth"];

// 字体
const FONT_PATH = "assets/fonts/ABCFavoritHebrewBoldVariable-Trial.ttf";
let fontObj = null;
let fontOK = false;

// 颜色（用你之前 draw.html 的：SB 方块 + Hue 条）
let hueVal = 220;
let satVal = 100;
let briVal = 80;
let currentColor;

// 颜色面板布局
const COLOR_PANEL_H = 190;
const COLOR_MAIN = { x: 10, y: 10, w: cw - 30 - 10, h: COLOR_PANEL_H }; // 左边大块
const COLOR_HUE  = { x: cw - 30, y: 10, w: 20, h: COLOR_PANEL_H };      // 右边色条

let sbGraphic, hueGraphic;

/* =================== UI：Sliders / Buttons =================== */
// ✅ Phase Slider 已删除 -> 只剩 5 个
const sliderName = ["Scale", "Stroke Weight", "Amplitude", "Frequency", "Animation Speed"];
let sliders = [];
let capButtons = [];

function preload() {
  // 尝试加载字体（变量字体可能失败）
  fontObj = loadFont(
    FONT_PATH,
    () => { fontOK = true; },
    () => { fontOK = false; fontObj = null; }
  );
}

function setup() {
  createCanvas(CANVAS_W, CANVAS_H);
  pixelDensity(1);

  // 初始颜色
  currentColor = color("#ffffff");

  // 构建颜色面板图形
  buildHueGraphic();
  buildSBGraphic();
  updateCurrentColorFromHSV(false);

  // Sliders：从 360 到 760 垂直排布（原来你是 400..750，这里更均匀）
  const sliderStartY = 360;
  const sliderEndY   = 760;
  for (let i = 0; i < slidersCount(); i++) {
    const y = map(i, 0, slidersCount() - 1, sliderStartY, sliderEndY);
    sliders.push(new Slider(100, y, 150, 40, sliderName[i], 0.5));
  }

  // Buttons（右侧）
  const capNames = ["Save", "Toggle Animation", "Reset", "Sin", "Square", "Triangle", "Sawtooth"];
  for (let i = 0; i < capNames.length; i++) {
    const y = map(i, 0, capNames.length - 1, 55, 500);
    capButtons.push(new CapButton(width - 120, y, 150, 30, capNames[i]));
  }
}

function slidersCount() { return 5; }

function draw() {
  background(240);

  updateParameters();
  drawGrid();

  // 绘制字形（如果字体失败，给提示）
  if (!fontOK || !fontObj) {
    drawFontFailHint();
  } else {
    push();
    translate(width / 2, height / 2);
    scale(scaleVal);
    drawGlyphFromInput();   // ✅ 用输入框的内容绘制
    pop();
  }

  // 左侧面板底色
  noStroke();
  fill(31, 30, 36);
  rect(0, 0, cw, height);

  // 颜色模块（旧版 draw.html 风格）
  drawColorPanel();

  // 右下角函数预览
  drawFunctionDisplay();

  if (isAnimating) t += animationSpeed;

  // Sliders
  for (let s of sliders) s.run();

  // Buttons
  for (let b of capButtons) b.display();
}

/* =================== 网格 =================== */
function drawGrid() {
  stroke(220);
  strokeWeight(1);

  const step = 25;
  for (let x = cw; x <= width; x += step) line(x, ch, x, height);
  for (let y = ch; y <= height; y += step) line(cw, y, width, y);
}

/* =================== 关键：把 Processing 的“曲线扰动理念”用于字形 ===================
   思路：textToPoints 得到轮廓点序列
   对每个点沿“局部法线方向”偏移：offset = applyFunction(frequency*dis*TWO_PI + t) * amplitude
   这样仍然是“路径被数学函数扰动”的理念，而不是我之前那种径向随机点云。
*/
function drawGlyphFromInput() {
  const txt = (document.getElementById("glyphInput").value || "A").trim();
  if (!txt) return;

  stroke(currentColor);
  strokeWeight(strokeW);
  noFill();

  // 字号（跟 scaleVal 配合）
  const fontSize = 240;

  // 先做 bounds，让文字居中在(0,0)
  const b = fontObj.textBounds(txt, 0, 0, fontSize);

  // textToPoints（点密度可调）
  const pts = fontObj.textToPoints(txt, -b.x - b.w/2, -b.y + b.h/2, fontSize, {
    sampleFactor: 0.12,
    simplifyThreshold: 0
  });

  if (!pts || pts.length < 2) return;

  // 断开不同轮廓：距离太大就断开
  const breakDist = max(10, fontSize * 0.07);

  // 画线段（按点序列连接），每个点沿法线偏移
  let started = false;
  let prev = null;
  let disAcc = 0;

  for (let i = 0; i < pts.length; i++) {
    const p = pts[i];

    if (prev) {
      const d = dist(prev.x, prev.y, p.x, p.y);
      if (d > breakDist) {
        if (started) endShape();
        started = false;
        prev = null;
        disAcc = 0;
      } else {
        disAcc += d * 0.01; // 类似你 Processing 里 dis*0.01 的尺度
      }
    }

    // 求“局部切线方向”（用前后点）
    const p0 = pts[max(0, i - 1)];
    const p1 = pts[min(pts.length - 1, i + 1)];
    let tx = p1.x - p0.x;
    let ty = p1.y - p0.y;
    const tl = max(1e-6, sqrt(tx*tx + ty*ty));
    tx /= tl; ty /= tl;

    // 法线 = (-ty, tx)
    const nx = -ty;
    const ny = tx;

    // ✅ Phase 已删除：输入只剩 frequency * dis * TWO_PI + t
    const offset = applyFunction(frequency * disAcc * TWO_PI + t) * amplitude;

    const x = p.x + nx * offset;
    const y = p.y + ny * offset;

    if (!started) {
      beginShape();
      started = true;
    }

    // Sin / Triangle 用 curveVertex 更像你原来
    if (currentFunction === 0 || currentFunction === 2) curveVertex(x, y);
    else vertex(x, y);

    prev = p;
  }

  if (started) endShape();
}

/* =================== 函数 =================== */
function applyFunction(tt) {
  switch (currentFunction) {
    case 0: return sin(tt);
    case 1: return (tt % TWO_PI < PI) ? 1 : -1;
    case 2: return asin(sin(tt)) * 2 / PI;
    case 3: return (tt % TWO_PI) / PI - 1;
    default: return sin(tt);
  }
}

/* =================== 参数更新（Phase 已删） =================== */
function updateParameters() {
  scaleVal = map(sliders[0].val, 0, 1, 0.5, 3);
  strokeW = map(sliders[1].val, 0, 1, 0.5, 20);
  amplitude = map(sliders[2].val, 0, 1, 0, maxAmp);
  frequency = map(sliders[3].val, 0, 1, 0.1, 5);
  animationSpeed = map(sliders[4].val, 0, 1, 0, 0.1);
}

/* =================== 右下角函数预览（Phase 已删） =================== */
function drawFunctionDisplay() {
  const displayWidth = 250;
  const displayHeight = 250;
  const margin = 50;

  stroke(0);
  strokeWeight(3);

  push();
  translate(width - displayWidth/2 - margin, height - displayHeight/2 - margin);
  line(-displayWidth/2, 0, displayWidth/2, 0);
  line(0, -displayHeight/2, 0, displayHeight/2);

  fill(0);
  noStroke();
  textSize(15);
  triangle(-5, -displayHeight/2, 5, -displayHeight/2, 0, -displayHeight/2-15);
  triangle(displayWidth/2+15, 0, displayWidth/2, -5, displayWidth/2, 5);

  fill(0);
  textSize(15);
  textAlign(LEFT, TOP);
  text("y", 15, -displayHeight/2);
  text("x", displayWidth/2, 25);

  textSize(20);
  textAlign(CENTER, BOTTOM);
  text(functionNames[currentFunction] + " Function", 0, -displayHeight/2-40);
  pop();

  const picCol = color(140);
  stroke(picCol);
  noFill();
  strokeWeight(3);

  beginShape();
  for (let x = 0; x < displayWidth; x += 2) {
    const amp = map(amplitude, 0, maxAmp, 0, displayHeight / 2);
    const y = applyFunction(frequency * x * 0.02 + t) * amp; // ✅ 无 phase
    vertex(width - displayWidth - margin + x, height - displayHeight/2 - margin - y);
  }
  endShape();
}

/* =================== 颜色模块（复用你之前 draw.html 的逻辑） =================== */
function buildHueGraphic() {
  hueGraphic = createGraphics(COLOR_HUE.w, COLOR_HUE.h);
  hueGraphic.colorMode(HSB, 360, 100, 100);
  hueGraphic.noStroke();
  hueGraphic.loadPixels();

  for (let y = 0; y < COLOR_HUE.h; y++) {
    const h = map(y, 0, COLOR_HUE.h - 1, 0, 360);
    const c = hueGraphic.color(h, 100, 100);
    for (let x = 0; x < COLOR_HUE.w; x++) {
      const idx = (y * COLOR_HUE.w + x) * 4;
      hueGraphic.pixels[idx]     = red(c);
      hueGraphic.pixels[idx + 1] = green(c);
      hueGraphic.pixels[idx + 2] = blue(c);
      hueGraphic.pixels[idx + 3] = 255;
    }
  }
  hueGraphic.updatePixels();
}

function buildSBGraphic() {
  sbGraphic = createGraphics(COLOR_MAIN.w, COLOR_MAIN.h);
  sbGraphic.colorMode(HSB, 360, 100, 100);
  sbGraphic.noStroke();
  sbGraphic.loadPixels();

  for (let y = 0; y < COLOR_MAIN.h; y++) {
    for (let x = 0; x < COLOR_MAIN.w; x++) {
      const s = map(x, 0, COLOR_MAIN.w - 1, 0, 100);
      const b = map(y, 0, COLOR_MAIN.h - 1, 100, 0);
      const c = sbGraphic.color(hueVal, s, b);
      const idx = (y * COLOR_MAIN.w + x) * 4;
      sbGraphic.pixels[idx]     = red(c);
      sbGraphic.pixels[idx + 1] = green(c);
      sbGraphic.pixels[idx + 2] = blue(c);
      sbGraphic.pixels[idx + 3] = 255;
    }
  }
  sbGraphic.updatePixels();
}

function updateCurrentColorFromHSV(rebuildSB) {
  push();
  colorMode(HSB, 360, 100, 100);
  currentColor = color(hueVal, satVal, briVal);
  pop();
  if (rebuildSB) buildSBGraphic();
}

function drawColorPanel() {
  imageMode(CORNER);
  image(sbGraphic, COLOR_MAIN.x, COLOR_MAIN.y);
  image(hueGraphic, COLOR_HUE.x, COLOR_HUE.y);

  // Hue 标记
  const hy = map(hueVal, 0, 360, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
  stroke(255);
  strokeWeight(2);
  line(COLOR_HUE.x - 4, hy, COLOR_HUE.x, hy);
  line(COLOR_HUE.x + COLOR_HUE.w, hy, COLOR_HUE.x + COLOR_HUE.w + 4, hy);

  // 当前色块（在下面画一个小条）
  noStroke();
  fill(currentColor);
  rect(10, COLOR_MAIN.y + COLOR_MAIN.h + 10, cw - 20, 16, 8);
}

function handleColorClick() {
  // SB
  if (mouseX >= COLOR_MAIN.x && mouseX <= COLOR_MAIN.x + COLOR_MAIN.w &&
      mouseY >= COLOR_MAIN.y && mouseY <= COLOR_MAIN.y + COLOR_MAIN.h) {

    const sx = constrain(mouseX, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
    const sy = constrain(mouseY, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);

    satVal = map(sx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w, 0, 100);
    briVal = map(sy, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h, 100, 0);

    updateCurrentColorFromHSV(false);
    return true;
  }

  // Hue
  if (mouseX >= COLOR_HUE.x && mouseX <= COLOR_HUE.x + COLOR_HUE.w &&
      mouseY >= COLOR_HUE.y && mouseY <= COLOR_HUE.y + COLOR_HUE.h) {

    const yy = constrain(mouseY, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
    hueVal = map(yy, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h, 0, 360);

    updateCurrentColorFromHSV(true);
    return true;
  }

  return false;
}

/* =================== 鼠标交互 =================== */
function mousePressed() {
  // 颜色面板优先
  if (handleColorClick()) return;

  // sliders
  for (let s of sliders) s.click();

  // buttons
  for (let b of capButtons) {
    if (b.hover()) {
      handleButtonPress(b.str);
      return;
    }
  }
}

function mouseReleased() {
  for (let s of sliders) s.state = false;
}

function handleButtonPress(label) {
  switch (label) {
    case "Save":
      saveCanvas("FontPath", "png");
      break;
    case "Toggle Animation":
      isAnimating = !isAnimating;
      break;
    case "Reset":
      resetToDefaults();
      break;
    default:
      for (let i = 0; i < functionNames.length; i++) {
        if (label === functionNames[i]) currentFunction = i;
      }
      break;
  }
}

function resetToDefaults() {
  currentFunction = 0;
  isAnimating = true;
  t = 0;
  for (let s of sliders) {
    s.val = 0.5;
    s.state = false;
  }
  // 颜色回到一个偏蓝的默认
  hueVal = 220; satVal = 100; briVal = 80;
  updateCurrentColorFromHSV(true);

  // 输入框也回到 A
  document.getElementById("glyphInput").value = "A";
}

/* =================== Slider / CapButton =================== */
class CapButton {
  constructor(x, y, w, h, str) {
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str;
    this.scl=1; this.gray=150; this.state=false;
  }
  hover() {
    return (abs(mouseX-this.x)<this.w/2 && abs(mouseY-this.y)<this.h/2);
  }
  display() {
    push();
    rectMode(CENTER);
    fill(this.gray);

    if (this.hover() || this.state) {
      this.gray = lerp(this.gray, 200, 0.12);
      this.scl = lerp(this.scl, 1.2, 0.12);
    } else {
      this.gray = lerp(this.gray, 150, 0.12);
      this.scl = lerp(this.scl, 1.0, 0.12);
    }

    noStroke();
    translate(this.x, this.y);
    push();
    scale(this.scl);
    rect(0, 0, this.w, this.h, 40);
    pop();

    fill(255);
    textSize(this.h * 0.5);
    textAlign(CENTER, CENTER);
    text(this.str, 0, 0);
    pop();
  }
}

class Slider {
  constructor(x, y, w, h, str, val) {
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str; this.val=val;
    this.state=false;
  }
  hover() {
    return (abs(mouseX-this.x)<this.w/2 && abs(mouseY-this.y)<this.h/2);
  }
  click() {
    this.state = this.hover();
  }
  drag() {
    if (!this.state) return;
    let v = map(mouseX, this.x-this.w/2, this.x+this.w/2, 0, 1);
    v = constrain(v, 0, 1);
    this.val = lerp(this.val, v, 0.12);
  }
  run() {
    this.drag();
    this.display();
  }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);
    noStroke();

    fill(this.hover()?110:85);
    rect(0, 0, this.w, this.h, 100);

    const vw = map(this.val, 0, 1, 0, this.w);
    fill(this.hover()?160:120);
    rect(-this.w/2 + vw/2, 0, vw, this.h, 100);

    fill(255);
    textSize(this.h * 0.4);
    textAlign(CENTER, CENTER);
    text(this.str, 0, 0);
    pop();
  }
}

/* =================== 字体失败提示 =================== */
function drawFontFailHint() {
  push();
  fill(0, 0, 0, 60);
  noStroke();
  rect(cw + 40, 60, width - cw - 80, 180, 18);

  fill(255);
  textAlign(LEFT, TOP);
  textSize(16);
  text("Font load failed (or Variable font unsupported)", cw + 70, 90);

  textSize(12);
  fill(230);
  text(
    "你的字形绘制依赖 textToPoints()，必须成功加载字体。\n\n请确认字体能被浏览器直接打开：\n" +
    location.origin + "/" + FONT_PATH + "\n\n如果能打开但仍失败：说明变量字体不兼容，\n请换一个普通 TTF/OTF（非 Variable）。",
    cw + 70, 120
  );
  pop();
}
</script>
</body>
</html>
