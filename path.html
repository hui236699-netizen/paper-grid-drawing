<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Font Path Method</title>
  <style>
    :root{
      --bg:#0f1013;
      --panel:#17181d;
      --panel2:#1f2027;
      --ink:#f2f2f2;
      --muted:#b7b7b7;
      --line:rgba(255,255,255,.10);
      --accent:#7c5cff;
      --btn:#2a2c36;
      --btn2:#333545;
      --grid1:rgba(255,255,255,.06);
      --grid2:rgba(255,255,255,.10);
      --danger:#ff4d4d;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Helvetica Neue", Arial, "PingFang SC";
      background:var(--bg);
      color:var(--ink);
      overflow:hidden;
    }
    a{ color:inherit; text-decoration:none; }

    /* top bar */
    header{
      height:64px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-bottom:1px solid var(--line);
      background:rgba(15,16,19,.85);
      backdrop-filter: blur(10px);
    }
    .nav{
      width:min(1200px, calc(100% - 32px));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{ display:flex; align-items:center; gap:10px; font-weight:900; }
    .dot{ width:10px;height:10px;border-radius:999px;background:var(--accent); }
    .nav-actions{ display:flex; gap:10px; align-items:center; }
    .pill{
      padding:10px 14px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      font-weight:800;
      background:transparent;
      user-select:none;
    }
    .pill.primary{
      background:rgba(124,92,255,.16);
      border-color:rgba(124,92,255,.45);
    }

    /* layout */
    .app{
      height: calc(100% - 64px);
      display:flex;
      min-width: 320px;
    }
    .side{
      width:280px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border-right:1px solid var(--line);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .card{
      border:1px solid var(--line);
      border-radius:18px;
      background: rgba(255,255,255,.03);
      padding:12px;
    }
    .title{
      font-weight:900;
      margin:0 0 6px;
      letter-spacing:.2px;
    }
    .desc{
      margin:0;
      color:var(--muted);
      font-size:12.5px;
      line-height:1.55;
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .btn{
      background: var(--btn);
      color: var(--ink);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;
      padding:10px 12px;
      font-weight:900;
      cursor:pointer;
      user-select:none;
      transition:.12s ease;
    }
    .btn:hover{ transform: translateY(-1px); background: var(--btn2); }
    .btn.danger{ background: rgba(255,77,77,.12); border-color: rgba(255,77,77,.4); }
    .btn.small{ padding:8px 10px; font-size:12px; }
    .btn.on{
      background: rgba(124,92,255,.18);
      border-color: rgba(124,92,255,.55);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      padding:2px 6px;
      border:1px solid rgba(255,255,255,.18);
      border-bottom-width:2px;
      border-radius:8px;
      background: rgba(255,255,255,.06);
      color: #fff;
    }
    .hint{
      color: var(--muted);
      font-size:12px;
      line-height:1.55;
      margin-top:8px;
    }

    .main{
      flex:1;
      position:relative;
      overflow:hidden;
    }

    /* canvas wrap */
    .stage{
      position:absolute;
      inset:0;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    /* toast */
    .toast{
      position:absolute;
      left:16px;
      bottom:16px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color:#fff;
      font-size:12.5px;
      opacity:0;
      transform: translateY(6px);
      transition: .18s ease;
      pointer-events:none;
      backdrop-filter: blur(8px);
    }
    .toast.show{
      opacity:1;
      transform: translateY(0);
    }
  </style>
</head>

<body>
<header>
  <div class="nav">
    <div class="brand">
      <span class="dot"></span>
      <span>Font Playground · Path Method</span>
    </div>
    <div class="nav-actions">
      <a class="pill" href="index.html#choose">Back</a>
      <a class="pill primary" href="draw.html">Open Grid Builder</a>
    </div>
  </div>
</header>

<div class="app">
  <aside class="side">
    <div class="card">
      <p class="title">Tools</p>
      <div class="row" style="margin-bottom:6px;">
        <button id="toolSelect" class="btn on">Select</button>
        <button id="toolPen" class="btn">Pen</button>
      </div>
      <p class="desc">
        <b>Select</b>: drag anchors to move. <b>Pen</b>: click to add anchors.
      </p>
      <div class="hint">
        Delete anchor: <span class="kbd">Backspace</span>/<span class="kbd">Delete</span><br/>
        Constrain (45°): hold <span class="kbd">Shift</span><br/>
        Pan: hold <span class="kbd">Space</span> then drag<br/>
        Zoom: <span class="kbd">Ctrl</span> + mouse wheel (or trackpad pinch)
      </div>
    </div>

    <div class="card">
      <p class="title">Grid</p>
      <div class="row">
        <button id="toggleSnap" class="btn on small">Snap: ON</button>
        <button id="toggleGrid" class="btn on small">Grid: ON</button>
      </div>
      <div class="hint">
        All anchors will snap to grid when Snap is ON.
      </div>
    </div>

    <div class="card">
      <p class="title">Actions</p>
      <div class="row">
        <button id="undoBtn" class="btn small">Undo</button>
        <button id="redoBtn" class="btn small">Redo</button>
        <button id="clearBtn" class="btn danger small">Clear</button>
      </div>
      <div class="row" style="margin-top:10px;">
        <button id="exportBtn" class="btn small">Export SVG Path</button>
      </div>
      <div class="hint" id="stats">Anchors: 0</div>
    </div>

    <div class="card">
      <p class="title">About</p>
      <p class="desc">
        This is a first usable version of the Path editor. Next steps we can add:
        Bezier handles, closed shapes, boolean ops, stroke → outline, and font export.
      </p>
    </div>
  </aside>

  <main class="main">
    <div class="stage">
      <canvas id="cv"></canvas>
    </div>
    <div id="toast" class="toast"></div>
  </main>
</div>

<script>
(() => {
  // ====== Config ======
  const GRID = 36;              // grid size in px (world)
  const HIT_R = 10;             // anchor hit radius (screen)
  const ANCHOR_R = 5;           // anchor draw radius (screen)
  const PATH_W = 3;             // path stroke width (screen)
  const BG = "#f7f7f7";

  // ====== State ======
  let tool = "select"; // "select" | "pen"
  let showGrid = true;
  let snap = true;

  let anchors = []; // {x,y} in world coords
  let selected = -1;

  // view transform
  let camX = 0, camY = 0; // world offset
  let zoom = 1;

  // dragging
  let isDown = false;
  let draggingAnchor = false;
  let dragStart = null;
  let spacePan = false;
  let panStart = null;

  // undo/redo
  let undoStack = [];
  let redoStack = [];

  // ====== DOM ======
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const stats = document.getElementById("stats");
  const toast = document.getElementById("toast");

  const toolSelect = document.getElementById("toolSelect");
  const toolPen = document.getElementById("toolPen");

  const toggleGrid = document.getElementById("toggleGrid");
  const toggleSnap = document.getElementById("toggleSnap");

  const undoBtn = document.getElementById("undoBtn");
  const redoBtn = document.getElementById("redoBtn");
  const clearBtn = document.getElementById("clearBtn");
  const exportBtn = document.getElementById("exportBtn");

  // ====== Helpers ======
  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.classList.remove("show"), 1200);
  }

  function setTool(t){
    tool = t;
    toolSelect.classList.toggle("on", tool === "select");
    toolPen.classList.toggle("on", tool === "pen");
    showToast(tool === "select" ? "Select tool" : "Pen tool");
  }

  function pushUndo(){
    undoStack.push(JSON.stringify(anchors));
    if (undoStack.length > 200) undoStack.shift();
    redoStack.length = 0;
  }

  function snapToGrid(x,y){
    if(!snap) return {x,y};
    return {
      x: Math.round(x / GRID) * GRID,
      y: Math.round(y / GRID) * GRID
    };
  }

  function worldToScreen(p){
    return {
      x: (p.x + camX) * zoom,
      y: (p.y + camY) * zoom
    };
  }

  function screenToWorld(x,y){
    return {
      x: x / zoom - camX,
      y: y / zoom - camY
    };
  }

  function dist2(ax,ay,bx,by){
    const dx = ax-bx, dy=ay-by;
    return dx*dx+dy*dy;
  }

  function hitTestAnchor(mx,my){
    // mx,my are screen
    for(let i=anchors.length-1;i>=0;i--){
      const s = worldToScreen(anchors[i]);
      if(dist2(mx,my,s.x,s.y) <= HIT_R*HIT_R) return i;
    }
    return -1;
  }

  function constrain45(from, to){
    // from/to in world coords, returns constrained "to"
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    const ang = Math.atan2(dy, dx);
    const step = Math.PI / 4; // 45 deg
    const snapped = Math.round(ang / step) * step;
    const len = Math.hypot(dx,dy);
    return { x: from.x + Math.cos(snapped)*len, y: from.y + Math.sin(snapped)*len };
  }

  function updateStats(){
    stats.textContent = `Anchors: ${anchors.length}` + (selected>=0 ? `  ·  Selected: #${selected+1}` : "");
  }

  // ====== Resize & DPR ======
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = cv.getBoundingClientRect();
    cv.width = Math.round(r.width * dpr);
    cv.height = Math.round(r.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  // ====== Drawing ======
  function drawGrid(){
    if(!showGrid) return;
    const w = cv.getBoundingClientRect().width;
    const h = cv.getBoundingClientRect().height;

    // world origin at top-left; grid in world coords
    // find visible world range
    const topLeft = screenToWorld(0,0);
    const bottomRight = screenToWorld(w,h);

    const startX = Math.floor(topLeft.x / GRID) * GRID;
    const endX = Math.ceil(bottomRight.x / GRID) * GRID;
    const startY = Math.floor(topLeft.y / GRID) * GRID;
    const endY = Math.ceil(bottomRight.y / GRID) * GRID;

    ctx.save();
    ctx.lineWidth = 1;

    // minor lines
    ctx.strokeStyle = "rgba(0,0,0,.06)";
    for(let x=startX; x<=endX; x+=GRID){
      const sx = worldToScreen({x, y:0}).x;
      ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,h); ctx.stroke();
    }
    for(let y=startY; y<=endY; y+=GRID){
      const sy = worldToScreen({x:0, y}).y;
      ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(w,sy); ctx.stroke();
    }

    // major lines (every 5)
    ctx.strokeStyle = "rgba(0,0,0,.10)";
    const major = GRID*5;
    const startMX = Math.floor(topLeft.x / major) * major;
    const endMX = Math.ceil(bottomRight.x / major) * major;
    const startMY = Math.floor(topLeft.y / major) * major;
    const endMY = Math.ceil(bottomRight.y / major) * major;

    for(let x=startMX; x<=endMX; x+=major){
      const sx = worldToScreen({x, y:0}).x;
      ctx.beginPath(); ctx.moveTo(sx,0); ctx.lineTo(sx,h); ctx.stroke();
    }
    for(let y=startMY; y<=endMY; y+=major){
      const sy = worldToScreen({x:0, y}).y;
      ctx.beginPath(); ctx.moveTo(0,sy); ctx.lineTo(w,sy); ctx.stroke();
    }

    ctx.restore();
  }

  function drawPath(){
    if(anchors.length < 2) return;
    ctx.save();
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.lineWidth = PATH_W;
    ctx.strokeStyle = "#2b2d33";
    ctx.beginPath();
    const s0 = worldToScreen(anchors[0]);
    ctx.moveTo(s0.x, s0.y);
    for(let i=1;i<anchors.length;i++){
      const s = worldToScreen(anchors[i]);
      ctx.lineTo(s.x, s.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawAnchors(){
    ctx.save();
    for(let i=0;i<anchors.length;i++){
      const s = worldToScreen(anchors[i]);

      // anchor dot
      ctx.beginPath();
      ctx.arc(s.x, s.y, ANCHOR_R, 0, Math.PI*2);
      ctx.fillStyle = (i===selected) ? "#7c5cff" : "#111";
      ctx.fill();

      // ring
      ctx.beginPath();
      ctx.arc(s.x, s.y, ANCHOR_R+3, 0, Math.PI*2);
      ctx.strokeStyle = (i===selected) ? "rgba(124,92,255,.65)" : "rgba(17,17,17,.25)";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    ctx.restore();
  }

  function draw(){
    const w = cv.getBoundingClientRect().width;
    const h = cv.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    // background
    ctx.save();
    ctx.fillStyle = BG;
    ctx.fillRect(0,0,w,h);
    ctx.restore();

    drawGrid();
    drawPath();
    drawAnchors();

    updateStats();
  }

  // ====== Events ======
  function pointerPos(e){
    const r = cv.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  cv.addEventListener("mousedown", (e)=>{
    cv.focus?.();
    isDown = true;

    // space pan
    if(spacePan){
      panStart = { ...pointerPos(e), camX, camY };
      return;
    }

    const m = pointerPos(e);
    const hit = hitTestAnchor(m.x, m.y);

    if(tool === "select"){
      if(hit >= 0){
        selected = hit;
        draggingAnchor = true;
        dragStart = { m, world: {...anchors[hit]} };
      }else{
        selected = -1;
      }
      draw();
      return;
    }

    if(tool === "pen"){
      // if clicking existing anchor -> select it
      if(hit >= 0){
        selected = hit;
        draggingAnchor = true;
        dragStart = { m, world: {...anchors[hit]} };
        draw();
        return;
      }

      pushUndo();

      let wpt = screenToWorld(m.x, m.y);
      if(e.shiftKey && anchors.length>0){
        wpt = constrain45(anchors[anchors.length-1], wpt);
      }
      wpt = snapToGrid(wpt.x, wpt.y);
      anchors.push({x:wpt.x, y:wpt.y});
      selected = anchors.length - 1;
      draw();
    }
  });

  cv.addEventListener("mousemove", (e)=>{
    const m = pointerPos(e);

    if(!isDown){
      // hover cursor
      const hit = hitTestAnchor(m.x, m.y);
      cv.style.cursor = spacePan ? "grab" : (hit>=0 ? "pointer" : (tool==="pen" ? "crosshair" : "default"));
      return;
    }

    if(spacePan && panStart){
      cv.style.cursor = "grabbing";
      const dx = (m.x - panStart.x) / zoom;
      const dy = (m.y - panStart.y) / zoom;
      camX = panStart.camX + dx;
      camY = panStart.camY + dy;
      draw();
      return;
    }

    if(draggingAnchor && selected>=0 && dragStart){
      let wpt = screenToWorld(m.x, m.y);

      // shift constrain relative to original anchor
      if(e.shiftKey){
        wpt = constrain45(dragStart.world, wpt);
      }

      wpt = snapToGrid(wpt.x, wpt.y);
      anchors[selected] = {x:wpt.x, y:wpt.y};
      draw();
    }
  });

  cv.addEventListener("mouseup", ()=>{
    isDown = false;
    draggingAnchor = false;
    dragStart = null;
    panStart = null;
    cv.style.cursor = spacePan ? "grab" : "default";
  });

  cv.addEventListener("mouseleave", ()=>{
    isDown = false;
    draggingAnchor = false;
    dragStart = null;
    panStart = null;
  });

  // Zoom (Ctrl + wheel)
  cv.addEventListener("wheel", (e)=>{
    if(!e.ctrlKey) return;
    e.preventDefault();

    const m = pointerPos(e);
    const before = screenToWorld(m.x, m.y);

    const factor = (e.deltaY < 0) ? 1.08 : 1/1.08;
    const next = Math.min(4, Math.max(0.35, zoom * factor));
    zoom = next;

    const after = screenToWorld(m.x, m.y);
    camX += (after.x - before.x);
    camY += (after.y - before.y);

    draw();
  }, { passive:false });

  // Keyboard
  window.addEventListener("keydown", (e)=>{
    if(e.code === "Space"){
      spacePan = true;
      cv.style.cursor = "grab";
    }

    if(e.key === "Escape"){
      selected = -1;
      draw();
    }

    // Delete selected anchor
    if((e.key === "Backspace" || e.key === "Delete") && selected >= 0){
      e.preventDefault();
      pushUndo();
      anchors.splice(selected, 1);
      selected = Math.min(selected, anchors.length-1);
      draw();
      showToast("Anchor deleted");
    }

    // Undo / Redo
    if((e.ctrlKey || e.metaKey) && (e.key === "z" || e.key === "Z")){
      e.preventDefault();
      if(undoStack.length){
        redoStack.push(JSON.stringify(anchors));
        anchors = JSON.parse(undoStack.pop());
        selected = -1;
        draw();
        showToast("Undo");
      }
    }
    if((e.ctrlKey || e.metaKey) && (e.key === "y" || e.key === "Y")){
      e.preventDefault();
      if(redoStack.length){
        undoStack.push(JSON.stringify(anchors));
        anchors = JSON.parse(redoStack.pop());
        selected = -1;
        draw();
        showToast("Redo");
      }
    }
  });

  window.addEventListener("keyup", (e)=>{
    if(e.code === "Space"){
      spacePan = false;
      cv.style.cursor = "default";
    }
  });

  // Buttons
  toolSelect.addEventListener("click", ()=> setTool("select"));
  toolPen.addEventListener("click", ()=> setTool("pen"));

  toggleGrid.addEventListener("click", ()=>{
    showGrid = !showGrid;
    toggleGrid.classList.toggle("on", showGrid);
    toggleGrid.textContent = `Grid: ${showGrid ? "ON" : "OFF"}`;
    draw();
  });

  toggleSnap.addEventListener("click", ()=>{
    snap = !snap;
    toggleSnap.classList.toggle("on", snap);
    toggleSnap.textContent = `Snap: ${snap ? "ON" : "OFF"}`;
    draw();
  });

  undoBtn.addEventListener("click", ()=>{
    if(!undoStack.length) return;
    redoStack.push(JSON.stringify(anchors));
    anchors = JSON.parse(undoStack.pop());
    selected = -1;
    draw();
    showToast("Undo");
  });

  redoBtn.addEventListener("click", ()=>{
    if(!redoStack.length) return;
    undoStack.push(JSON.stringify(anchors));
    anchors = JSON.parse(redoStack.pop());
    selected = -1;
    draw();
    showToast("Redo");
  });

  clearBtn.addEventListener("click", ()=>{
    if(!anchors.length) return;
    pushUndo();
    anchors = [];
    selected = -1;
    draw();
    showToast("Cleared");
  });

  function toSvgPathD(){
    if(anchors.length === 0) return "";
    let d = `M ${anchors[0].x.toFixed(2)} ${anchors[0].y.toFixed(2)}`;
    for(let i=1;i<anchors.length;i++){
      d += ` L ${anchors[i].x.toFixed(2)} ${anchors[i].y.toFixed(2)}`;
    }
    return d;
  }

  exportBtn.addEventListener("click", async ()=>{
    const d = toSvgPathD();
    if(!d){
      showToast("No anchors to export");
      return;
    }
    try{
      await navigator.clipboard.writeText(d);
      showToast("SVG path d copied!");
    }catch(err){
      // fallback prompt
      window.prompt("Copy SVG path d:", d);
    }
  });

  // init
  setTool("select");
  resize();
  draw();
})();
</script>
</body>
</html>
