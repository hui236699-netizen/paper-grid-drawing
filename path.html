<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Path Method</title>
  <style>
    html, body { margin:0; padding:0; background:#0f1013; overflow:hidden; }
    canvas { display:block; }

    .glyphInput {
      position: absolute;
      background: #3A393D;
      color: #fff;
      border: 0;
      outline: none;
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 16px;
      width: 200px;
      box-sizing: border-box;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>
<body>
<script>
/* =================== 设计稿尺寸（虚拟画布） =================== */
const BASE_W = 1440;
const BASE_H = 900;

/* =================== 左侧栏参数（按设计稿坐标） =================== */
let cw = 240;
let showGrid = true;

/* =================== 你的参数（保留逻辑） =================== */
let maxAmp = 50;
let t = 0;

let scaleVal = 1.0;
let strokeW = 2;
let amplitude = 10;
let frequency = 1;

// phase 逻辑保留（不做滑块 UI）
let phase = 0;

let isAnimating = true;
let animationSpeed = 0.02;

let currentFunction = 0;
const functionNames = ["Sin", "Square", "Triangle", "Sawtooth"];

/* =================== UI 字体（仅用于按钮文字） =================== */
const FONT_PATH = "assets/fonts/ABCFavoritHebrewBoldVariable-Trial.ttf";
let uiFont = null;
let fontLoaded = false;

/* =================== 颜色模块（同 draw.html） =================== */
// ✅ 默认黑色
let hue = 0;
let sat = 0;
let bri = 0;
let currentColor;

const COLOR_PANEL_H = 190;

const COLOR_MAIN = { x: 0, y: 0, w: cw - 30, h: COLOR_PANEL_H };
const COLOR_HUE  = { x: cw - 30, y: 0, w: 30, h: COLOR_PANEL_H };

let sbGraphic, hueGraphic;

const RECENT_RECTS = [
  { x: 16,  y: COLOR_PANEL_H + 25, w: 28, h: 28 },
  { x: 62,  y: COLOR_PANEL_H + 25, w: 28, h: 28 },
  { x: 108, y: COLOR_PANEL_H + 25, w: 28, h: 28 },
  { x: 154, y: COLOR_PANEL_H + 25, w: 28, h: 28 },
  { x: 200, y: COLOR_PANEL_H + 25, w: 28, h: 28 }
];

const defaultRecentHex = ["#482BCC","#FF04A5","#FFE900","#8CE255","#8EC8EC"];
let recentColors = [];

/* =================== 左侧四按钮（位置同 draw.html） =================== */
const FUNC_RECTS = {
  reset: { x: 20,  y: COLOR_PANEL_H + 68,  w: 90, h: 32 },
  pause: { x: 130, y: COLOR_PANEL_H + 68,  w: 90, h: 32 },
  grid:  { x: 20,  y: COLOR_PANEL_H + 112, w: 90, h: 32 },
  save:  { x: 130, y: COLOR_PANEL_H + 112, w: 90, h: 32 }
};

let resetButton, pauseButton, gridButton, saveButton;

/* =================== 输入框 & Randomize =================== */
let glyphInput;
let glyphChar = "X"; // 默认 X
let randomizeButton;

/* =================== 5个滑块（下移） =================== */
const sliderName = ["Scale", "Stroke Weight", "Amplitude", "Frequency", "Animation Speed"];
let sliders = [];

/* =================== 波形按钮（右边） =================== */
let waveButtons = [];

/* =================== 适配：窗口canvas + 保持比例缩放 =================== */
let fitScale = 1;
let fitOffX = 0;
let fitOffY = 0;

/* 坐标转换：屏幕(像素) -> 设计稿坐标 */
function vMouseX() { return (mouseX - fitOffX) / fitScale; }
function vMouseY() { return (mouseY - fitOffY) / fitScale; }
function vInBounds() {
  const mx = vMouseX(), my = vMouseY();
  return mx >= 0 && mx <= BASE_W && my >= 0 && my <= BASE_H;
}

/* 设计稿坐标 -> 屏幕(像素) */
function toScreenX(x) { return fitOffX + x * fitScale; }
function toScreenY(y) { return fitOffY + y * fitScale; }

/* =================== 单线骨架字库（X 就两条线段） =================== */
const STICK_FONT = {
  "X": [
    [[-65,-110],[ 65,110]],   // ✅ 仅一条长线段
    [[ 65,-110],[-65,110]]    // ✅ 仅一条长线段
  ],
  "Y": [
    [[-60,-110],[0,0]],
    [[ 60,-110],[0,0]],
    [[ 0,  0],[0,110]]
  ],
  "O": [
    [[  0,-110],[ 45,-100],[ 75,-70],[ 95,-25],[ 95, 25],[ 75, 70],[ 45,100],[  0,110],
      [-45,100],[-75, 70],[-95, 25],[-95,-25],[-75,-70],[-45,-100],[  0,-110]]
  ],
  "A": [
    [[-55,110],[0,-110]],
    [[ 55,110],[0,-110]],
    [[-35, 30],[35, 30]]
  ],
  "?": [
    [[-20,-60],[0,-100],[20,-60],[0,-20]],
    [[0,60],[0,80]]
  ],
  " ": []
};

function normalizeGlyphChar(ch) {
  if (!ch || ch.length === 0) return " ";
  const c = ch[0];
  const up = c.toUpperCase();
  if (STICK_FONT[up]) return up;
  if (STICK_FONT[c]) return c;
  return "?";
}

/* =================== setup =================== */
function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);

  // 默认黑色
  currentColor = color(0);

  recentColors = defaultRecentHex.map(h => color(h));
  addRecentColor(currentColor);

  buildHueGraphic();
  buildSBGraphic();

  resetButton = rectToCapButton(FUNC_RECTS.reset, "Reset");
  pauseButton = rectToCapButton(FUNC_RECTS.pause, "Pause");
  gridButton  = rectToCapButton(FUNC_RECTS.grid,  "Grid");
  saveButton  = rectToCapButton(FUNC_RECTS.save,  "Save");

  // 输入框
  glyphInput = createInput("X");
  glyphInput.addClass("glyphInput");
  glyphInput.attribute("maxlength", "1");
  glyphInput.input(() => {
    let v = glyphInput.value();
    if (v.length === 0) { glyphChar = ""; return; }
    if (v.length > 1) { v = v[0]; glyphInput.value(v); }
    glyphChar = v;
  });
  glyphInput.elt.addEventListener("blur", () => {
    if (!glyphInput.value() || glyphInput.value().length === 0) {
      glyphChar = "X";
      glyphInput.value("X");
    }
  });

  // Randomize 按钮（放输入框下面）
  // 输入框设计稿位置：x=20, y=COLOR_PANEL_H+160
  const randRect = { x: 20, y: COLOR_PANEL_H + 210, w: 200, h: 32 };
  randomizeButton = rectToCapButton(randRect, "Randomize");

  // ✅ 原 5 个滑块整体下移（从 randomize 下面开始）
  const firstSliderY = randRect.y + 60;
  const gap = 54;
  for (let i = 0; i < 5; i++) {
    sliders.push(new Slider(120, firstSliderY + i * gap, 200, 34, sliderName[i], 0.5));
  }

  // 右侧波形按钮（设计稿坐标）
  const bx = BASE_W - 120;
  const by0 = 160;
  const bGap = 46;
  const names = ["Sin","Square","Triangle","Sawtooth"];
  for (let i = 0; i < 4; i++) {
    waveButtons.push(new CapButton(bx, by0 + i*bGap, 150, 30, names[i]));
  }
  setWaveSelected(0);

  calcFit();
  placeGlyphInput();

  tryLoadUIFont();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  calcFit();
  placeGlyphInput();
}

/* 计算保持比例的缩放与偏移（居中适配） */
function calcFit() {
  fitScale = min(width / BASE_W, height / BASE_H);
  const drawW = BASE_W * fitScale;
  const drawH = BASE_H * fitScale;
  fitOffX = (width  - drawW) / 2;
  fitOffY = (height - drawH) / 2;
}

/* 输入框定位（设计稿坐标 -> 屏幕像素） */
function placeGlyphInput() {
  if (!glyphInput) return;
  const inputX = 20;
  const inputY = COLOR_PANEL_H + 160;
  glyphInput.position(Math.round(toScreenX(inputX)), Math.round(toScreenY(inputY)));
  glyphInput.size(Math.round(200 * fitScale), Math.round(36 * fitScale));
  glyphInput.style("font-size", Math.max(12, Math.round(16 * fitScale)) + "px");
  glyphInput.style("border-radius", Math.round(12 * fitScale) + "px");
  glyphInput.style("padding", Math.round(8 * fitScale) + "px " + Math.round(10 * fitScale) + "px");
}

function draw() {
  background("#0f1013");

  // 把所有绘制锁定在“设计稿坐标系”
  push();
  translate(fitOffX, fitOffY);
  scale(fitScale);

  // 设计稿背景
  background(240);

  updateParameters();

  if (showGrid) drawGrid();

  // ✅ 字母永远在“设计稿中心”，最终就是屏幕中心
  push();
  translate(BASE_W / 2, BASE_H / 2);
  scale(scaleVal);
  drawGlyph(glyphChar);
  pop();

  // 左侧背景
  noStroke();
  fill("#1F1E24");
  rect(0, 0, cw, BASE_H);

  // 颜色模块
  drawColorPanel();
  drawRecentColors();

  // 四按钮
  pauseButton.str = isAnimating ? "Pause" : "Play";
  resetButton.display();
  pauseButton.display();
  gridButton.display();
  saveButton.display();

  // 输入框标题
  fill(255);
  useUIFont();
  textAlign(LEFT, CENTER);
  textSize(12);
  text("Glyph", 20, COLOR_PANEL_H + 145);

  // Randomize
  randomizeButton.display();

  // 滑块
  for (let s of sliders) s.run();

  // 右侧波形按钮
  for (let b of waveButtons) b.display();

  // 函数预览
  drawFunctionDisplay();

  pop(); // 结束设计稿坐标系

  if (isAnimating) t += animationSpeed;

  // 输入框在缩放布局里：窗口变化/失焦时更新（打字时不抖）
  if (glyphInput && document.activeElement !== glyphInput.elt) placeGlyphInput();
}

/* =================== 网格：只画右侧区域 =================== */
function drawGrid() {
  const step = 25;
  stroke(220);
  strokeWeight(1);
  for (let x = cw; x <= BASE_W; x += step) line(x, 0, x, BASE_H);
  for (let y = 0; y <= BASE_H; y += step) line(cw, y, BASE_W, y);
}

/* =================== 字形绘制：单线骨架 + 你的扰动逻辑 =================== */
function drawGlyph(ch) {
  const key = normalizeGlyphChar(ch);
  const strokes = STICK_FONT[key] || STICK_FONT["?"];

  stroke(currentColor);
  strokeWeight(strokeW);
  strokeCap(ROUND);
  strokeJoin(ROUND);
  noFill();

  for (const strokePts of strokes) {
    if (!strokePts || strokePts.length < 2) continue;
    for (let i = 0; i < strokePts.length - 1; i++) {
      const [x1, y1] = strokePts[i];
      const [x2, y2] = strokePts[i + 1];
      drawParametricCurve(x1, y1, x2, y2);
    }
  }
}

function drawParametricCurve(x1, y1, x2, y2) {
  beginShape();
  for (let i = 0; i <= 1.00001; i += 0.01) {
    let x = lerp(x1, x2, i);
    let y = lerp(y1, y2, i);

    let dis = dist(x, y, x1, y1) * 0.01;
    let offset = applyFunction(frequency * dis * TWO_PI + phase + t) * amplitude;

    let baseLen = dist(x1, y1, x2, y2) || 1;
    x += offset * (y2 - y1) / baseLen;
    y -= offset * (x2 - x1) / baseLen;

    if (currentFunction === 0 || currentFunction === 2) curveVertex(x, y);
    else vertex(x, y);
  }
  endShape();
}

function applyFunction(tt) {
  switch (currentFunction) {
    case 0: return sin(tt);
    case 1: return (tt % TWO_PI < PI) ? 1 : -1;
    case 2: return asin(sin(tt)) * 2 / PI;
    case 3: return (tt % TWO_PI) / PI - 1;
    default: return sin(tt);
  }
}

/* =================== 参数更新 =================== */
function updateParameters() {
  scaleVal = map(sliders[0].val, 0, 1, 0.5, 3);
  strokeW  = map(sliders[1].val, 0, 1, 0.5, 20);
  amplitude = map(sliders[2].val, 0, 1, 0, maxAmp);
  frequency = map(sliders[3].val, 0, 1, 0.1, 5);
  animationSpeed = map(sliders[4].val, 0, 1, 0, 0.1);
}

/* =================== 右下角函数预览（设计稿坐标） =================== */
function drawFunctionDisplay() {
  const displayWidth = 250;
  const displayHeight = 250;
  const margin = 50;

  stroke(0);
  strokeWeight(3);

  push();
  translate(BASE_W - displayWidth / 2 - margin, BASE_H - displayHeight / 2 - margin);

  line(-displayWidth / 2, 0, displayWidth / 2, 0);
  line(0, -displayHeight / 2, 0, displayHeight / 2);

  fill(0);
  noStroke();
  textSize(15);

  triangle(-5, -displayHeight / 2, 5, -displayHeight / 2, 0, -displayHeight / 2 - 15);
  triangle(displayWidth / 2 + 15, 0, displayWidth / 2, -5, displayWidth / 2, 5);

  fill(0);
  textAlign(LEFT, TOP);
  text("y", 15, -displayHeight / 2);
  text("x", displayWidth / 2, 25);

  textSize(20);
  textAlign(CENTER, BOTTOM);
  text(functionNames[currentFunction] + " Function", 0, -displayHeight / 2 - 40);
  pop();

  stroke(color(140));
  noFill();
  strokeWeight(3);

  beginShape();
  for (let x = 0; x < displayWidth; x += 2) {
    let amp = map(amplitude, 0, maxAmp, 0, displayHeight / 2);
    let y = applyFunction(frequency * x * 0.02 + phase + t) * amp;
    vertex(BASE_W - displayWidth - margin + x, BASE_H - displayHeight / 2 - margin - y);
  }
  endShape();
}

/* =================== 颜色模块（同 draw.html） =================== */
function buildHueGraphic() {
  hueGraphic = createGraphics(COLOR_HUE.w, COLOR_HUE.h);
  hueGraphic.pixelDensity(1);
  hueGraphic.colorMode(HSB, 360, 100, 100);
  hueGraphic.noStroke();
  hueGraphic.loadPixels();

  for (let y = 0; y < COLOR_HUE.h; y++) {
    let h = map(y, 0, COLOR_HUE.h - 1, 0, 360);
    let c = hueGraphic.color(h, 100, 100);
    for (let x = 0; x < COLOR_HUE.w; x++) {
      let idx = (y * COLOR_HUE.w + x) * 4;
      hueGraphic.pixels[idx]     = red(c);
      hueGraphic.pixels[idx + 1] = green(c);
      hueGraphic.pixels[idx + 2] = blue(c);
      hueGraphic.pixels[idx + 3] = 255;
    }
  }
  hueGraphic.updatePixels();
}

function buildSBGraphic() {
  sbGraphic = createGraphics(COLOR_MAIN.w, COLOR_MAIN.h);
  sbGraphic.pixelDensity(1);
  sbGraphic.colorMode(HSB, 360, 100, 100);
  sbGraphic.noStroke();
  sbGraphic.loadPixels();

  for (let y = 0; y < COLOR_MAIN.h; y++) {
    for (let x = 0; x < COLOR_MAIN.w; x++) {
      let sVal = map(x, 0, COLOR_MAIN.w - 1, 0, 100);
      let bVal = map(y, 0, COLOR_MAIN.h - 1, 100, 0);
      let c = sbGraphic.color(hue, sVal, bVal);
      let idx = (y * COLOR_MAIN.w + x) * 4;
      sbGraphic.pixels[idx]     = red(c);
      sbGraphic.pixels[idx + 1] = green(c);
      sbGraphic.pixels[idx + 2] = blue(c);
      sbGraphic.pixels[idx + 3] = 255;
    }
  }
  sbGraphic.updatePixels();
}

function drawColorPanel() {
  imageMode(CORNER);
  image(sbGraphic, COLOR_MAIN.x, COLOR_MAIN.y);
  image(hueGraphic, COLOR_HUE.x, COLOR_HUE.y);

  let huePosY = map(hue, 0, 360, 0, COLOR_HUE.h);
  stroke(255);
  strokeWeight(2);
  let hx = COLOR_HUE.x;
  let hy = COLOR_HUE.y + huePosY;
  line(hx - 4, hy, hx, hy);
  line(hx + COLOR_HUE.w, hy, hx + COLOR_HUE.w + 4, hy);
}

function drawRecentColors() {
  for (let i = 0; i < RECENT_RECTS.length; i++) {
    const r = RECENT_RECTS[i];
    stroke(40);
    strokeWeight(1);
    fill(recentColors[i] || color(0));
    rect(r.x, r.y, r.w, r.h, 6);

    if (recentColors[i] && colorsEqual(recentColors[i], currentColor)) {
      noFill();
      stroke(255);
      strokeWeight(2);
      rect(r.x - 3, r.y - 3, r.w + 6, r.h + 6, 8);
    }
  }
}

function updateCurrentColor() {
  push();
  colorMode(HSB, 360, 100, 100);
  currentColor = color(hue, sat, bri);
  pop();
  addRecentColor(currentColor);
}

function addRecentColor(c) {
  let nc = color(c);
  recentColors = recentColors.filter(rc => !colorsEqual(rc, nc));
  recentColors.unshift(nc);
  if (recentColors.length > 5) recentColors.length = 5;
}

function colorsEqual(c1, c2) {
  return red(c1) === red(c2) &&
         green(c1) === green(c2) &&
         blue(c1) === blue(c2);
}

function handleColorClick() {
  const mx = vMouseX();
  const my = vMouseY();
  if (!vInBounds()) return false;

  // SB
  if (mx >= COLOR_MAIN.x && mx <= COLOR_MAIN.x + COLOR_MAIN.w &&
      my >= COLOR_MAIN.y && my <= COLOR_MAIN.y + COLOR_MAIN.h) {
    let sx = constrain(mx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
    let sy = constrain(my, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);
    sat = map(sx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w, 0, 100);
    bri = map(sy, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h, 100, 0);
    updateCurrentColor();
    return true;
  }

  // Hue
  if (mx >= COLOR_HUE.x && mx <= COLOR_HUE.x + COLOR_HUE.w &&
      my >= COLOR_HUE.y && my <= COLOR_HUE.y + COLOR_HUE.h) {
    let hy = constrain(my, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
    hue = map(hy, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h, 0, 360);
    buildSBGraphic();
    updateCurrentColor();
    return true;
  }

  // Recent
  for (let i = 0; i < RECENT_RECTS.length; i++) {
    const r = RECENT_RECTS[i];
    if (mx >= r.x && mx <= r.x + r.w &&
        my >= r.y && my <= r.y + r.h) {
      if (recentColors[i]) {
        currentColor = color(recentColors[i]);
        addRecentColor(currentColor);
      }
      return true;
    }
  }

  return false;
}

/* =================== 交互 =================== */
function mousePressed() {
  if (!vInBounds()) return;

  if (resetButton.hover()) { resetToDefaults(); return; }
  if (pauseButton.hover()) { isAnimating = !isAnimating; return; }
  if (gridButton.hover())  { showGrid = !showGrid; return; }
  if (saveButton.hover())  { saveCanvas("FontPath", "png"); return; }

  if (handleColorClick()) return;

  if (randomizeButton.hover()) { randomizeParams(); return; }

  for (let s of sliders) s.click();

  for (let i = 0; i < waveButtons.length; i++) {
    if (waveButtons[i].hover()) { setWaveSelected(i); return; }
  }
}

function mouseReleased() {
  for (let s of sliders) s.state = false;
}

function setWaveSelected(idx) {
  currentFunction = idx;
  for (let i = 0; i < waveButtons.length; i++) waveButtons[i].state = (i === idx);
}

function resetToDefaults() {
  isAnimating = true;
  t = 0;
  phase = 0;

  for (let s of sliders) { s.val = 0.5; s.state = false; }

  // 黑色
  hue = 0; sat = 0; bri = 0;
  buildSBGraphic();
  updateCurrentColor();

  setWaveSelected(0);

  glyphChar = "X";
  if (glyphInput) glyphInput.value("X");
}

/* Randomize：随机一套参数（不动颜色，保持你自己选色） */
function randomizeParams() {
  // Scale / Stroke / Amp / Freq / Speed
  sliders[0].val = random(0.25, 0.85);   // scale
  sliders[1].val = random(0.10, 0.70);   // strokeW
  sliders[2].val = random(0.10, 0.95);   // amp
  sliders[3].val = random(0.15, 0.85);   // freq
  sliders[4].val = random(0.10, 0.70);   // speed
  for (let s of sliders) s.state = false;

  // 波形也随机
  setWaveSelected(floor(random(0, 4)));

  // 动起来更直观
  isAnimating = true;
}

/* =================== UI：CapButton / Slider（按设计稿坐标） =================== */
function rectToCapButton(rect, label) {
  const cx = rect.x + rect.w / 2;
  const cy = rect.y + rect.h / 2;
  return new CapButton(cx, cy, rect.w, rect.h, label, true);
}

class CapButton {
  constructor(x, y, w, h, str, useDrawStyle=false) {
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str;
    this.state=false;
    this.useDrawStyle = useDrawStyle;
  }
  hover() {
    const mx = vMouseX();
    const my = vMouseY();
    return (
      mx >= this.x - this.w / 2 && mx <= this.x + this.w / 2 &&
      my >= this.y - this.h / 2 && my <= this.y + this.h / 2
    );
  }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);

    if (this.useDrawStyle) {
      if (this.hover()) fill(90, 89, 93);
      else fill("#464548");
      noStroke();
      rect(0, 0, this.w, this.h, 40);
    } else {
      if (this.state) fill(110,109,113);
      else if (this.hover()) fill(90, 89, 93);
      else fill("#464548");
      noStroke();
      rect(0, 0, this.w, this.h, 40);
    }

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.5);
    text(this.str, 0, 0);
    pop();
  }
}

class Slider {
  constructor(cx, cy, w, h, label, val) {
    this.x = cx; this.y = cy; this.w = w; this.h = h;
    this.label = label;
    this.val = val;
    this.state = false;
  }
  hover() {
    const mx = vMouseX();
    const my = vMouseY();
    return (abs(mx - this.x) < this.w/2 && abs(my - this.y) < this.h/2);
  }
  click() { this.state = this.hover(); }
  drag() {
    if (!this.state) return;
    const mx = vMouseX();
    let v = map(mx, this.x - this.w/2, this.x + this.w/2, 0, 1);
    v = constrain(v, 0, 1);
    this.val = lerp(this.val, v, 0.12);
  }
  run() { this.drag(); this.display(); }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);
    noStroke();

    fill(this.hover() ? 110 : 85);
    rect(0, 0, this.w, this.h, 999);

    let vw = map(this.val, 0, 1, 0, this.w);
    fill(this.hover() ? 160 : 120);
    rect(-this.w/2 + vw/2, 0, vw, this.h, 999);

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.45);
    text(this.label, 0, 0);
    pop();
  }
}

/* =================== 字体加载（失败不影响） =================== */
function tryLoadUIFont() {
  loadFont(
    FONT_PATH,
    (f) => { uiFont = f; fontLoaded = true; },
    () => { uiFont = null; fontLoaded = false; }
  );
}
function useUIFont() {
  if (fontLoaded && uiFont) textFont(uiFont);
  else textFont("system-ui");
}
</script>
</body>
</html>
