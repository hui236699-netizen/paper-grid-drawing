<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Path Method</title>

  <style>
    html, body { height: 100%; margin: 0; background: #0f1013; overflow: hidden; }
    canvas { display: block; margin: 0 auto; }
  </style>

  <!-- p5.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>

<body>
<script>
  // =============== 基本参数（对应你的 Processing 代码） ===============
  const CANVAS_W = 1440;
  const CANVAS_H = 900;

  let maxAmp = 50;
  let t = 0;

  let scl = 1.0;
  let strokeW = 2;
  let amplitude = 10;
  let frequency = 1;
  let phase = 0;

  let isAnimating = true;
  let animationSpeed = 0.02;

  let ch = 0;
  let cw = 200;

  const functionNames = ["Sin", "Square", "Triangle", "Sawtooth"];
  let currentFunction = 0;

  // 当前颜色（用 HSV 方案替代 ControlP5 ColorWheel）
  let hueVal = 220;
  let satVal = 100;
  let briVal = 80;
  let currentColor;

  // =============== UI：颜色选择面板 ===============
  const COLOR_PANEL = {
    x: 10,
    y: 10,
    w: cw - 20,
    h: 170
  };
  const HUE_BAR = {
    x: 10 + (cw - 20) - 20,
    y: 10,
    w: 20,
    h: 170
  };
  const SB_PANEL = {
    x: 10,
    y: 10,
    w: (cw - 20) - 26,
    h: 170
  };

  let sbGraphic, hueGraphic;

  // =============== UI：滑块 & 按钮（对应你的 Slider / CapButton） ===============
  const sliderName = ["Scale", "Stroke Weight", "Amplitude", "Frequency", "Phase", "Animation Speed"];
  let sliders = new Array(6);
  let capButtons = new Array(7);

  // =============== 自定义 Slider（网页 p5 版） ===============
  class Slider {
    constructor(x, y, w, h, label, val) {
      this.x = x; this.y = y; this.w = w; this.h = h;
      this.label = label;
      this.val = val;
      this.state = false;
      this.animVal = val;
    }
    hover() {
      return (abs(mouseX - this.x) < this.w / 2 && abs(mouseY - this.y) < this.h / 2);
    }
    click() {
      this.state = this.hover();
    }
    drag() {
      if (!this.state) return;
      let v = map(mouseX, this.x - this.w / 2, this.x + this.w / 2, 0, 1);
      v = constrain(v, 0, 1);
      this.val = lerp(this.val, v, 0.18);
    }
    run() {
      this.drag();
      this.display();
    }
    display() {
      push();
      translate(this.x, this.y);
      rectMode(CENTER);
      noStroke();

      // 背条
      fill(50);
      rect(0, 0, this.w, this.h, 999);

      // 前景填充
      const vw = map(this.val, 0, 1, 0, this.w);
      fill(this.hover() ? 160 : 110);
      rect(-this.w / 2 + vw / 2, 0, vw, this.h, 999);

      // 文案
      fill(255);
      textAlign(CENTER, CENTER);
      textSize(this.h * 0.38);
      text(this.label, 0, 0);
      pop();
    }
  }

  // =============== 自定义 CapButton（网页 p5 版） ===============
  class CapButton {
    constructor(x, y, w, h, str) {
      this.x = x; this.y = y; this.w = w; this.h = h;
      this.str = str;
      this.s = 1;
      this.gray = 150;
      this.state = false;
    }
    hover() {
      return (abs(mouseX - this.x) < this.w / 2 && abs(mouseY - this.y) < this.h / 2);
    }
    display() {
      push();
      translate(this.x, this.y);
      rectMode(CENTER);

      if (this.hover() || this.state) {
        this.gray = lerp(this.gray, 200, 0.12);
        this.s = lerp(this.s, 1.06, 0.12);
      } else {
        this.gray = lerp(this.gray, 150, 0.12);
        this.s = lerp(this.s, 1.0, 0.12);
      }

      noStroke();
      fill(this.gray);
      push();
      scale(this.s);
      rect(0, 0, this.w, this.h, 999);
      pop();

      fill(255);
      textAlign(CENTER, CENTER);
      textSize(this.h * 0.55);
      text(this.str, 0, 0);
      pop();
    }
  }

  // =============== p5：setup / draw ===============
  function setup() {
    const c = createCanvas(CANVAS_W, CANVAS_H);
    pixelDensity(1);

    currentColor = color("#482BCC");
    buildHueGraphic();
    buildSBGraphic();
    updateCurrentColorFromHSV(false);

    // sliders：放在左侧面板下方
    for (let i = 0; i < sliders.length; i++) {
      const y = map(i, 0, sliders.length - 1, 240, 520);
      sliders[i] = new Slider(100, y, 170, 38, sliderName[i], 0.5);
    }

    // buttons：放在右侧（和你原 Processing 类似）
    const names = ["Save", "Toggle Animation", "Reset", "Sin", "Square", "Triangle", "Sawtooth"];
    for (let i = 0; i < capButtons.length; i++) {
      const y = map(i, 0, capButtons.length - 1, 80, 520);
      capButtons[i] = new CapButton(width - 120, y, 170, 34, names[i]);
    }
  }

  function draw() {
    background(240);

    updateParameters();
    drawGrid();

    // 中间绘制 MathA
    push();
    translate(width / 2, height / 2);
    scale(scl);
    drawMathA();
    pop();

    // 左侧深色面板
    noStroke();
    fill(31, 30, 36);
    rect(0, 0, cw, height);

    // 颜色选择 UI
    drawColorPanel();

    // 右下角函数预览
    drawFunctionDisplay();

    // 动画推进
    if (isAnimating) t += animationSpeed;

    // sliders
    for (let s of sliders) s.run();

    // buttons
    for (let b of capButtons) b.display();
  }

  // =============== 网格（对应你的 drawGrid） ===============
  function drawGrid() {
    stroke(220);
    strokeWeight(1);
    const step = 25;

    for (let i = 0; i <= width; i += step) {
      line(i + cw, ch, i + cw, height);
    }
    for (let i = ch; i <= height; i += step) {
      line(0 + cw, i, width + cw, i);
    }
  }

  // =============== MathA（对应你的 drawMathA / drawParametricCurve） ===============
  function drawMathA() {
    stroke(currentColor);
    strokeWeight(strokeW);
    noFill();

    // Left leg
    drawParametricCurve(-50, 100, 0, -100);
    // Right leg
    drawParametricCurve(50, 100, 0, -100);
    // Crossbar
    drawParametricCurve(-30, 30, 30, 30);
  }

  function drawParametricCurve(x1, y1, x2, y2) {
    beginShape();
    for (let i = 0; i <= 1.00001; i += 0.01) {
      let x = lerp(x1, x2, i);
      let y = lerp(y1, y2, i);

      const baseLen = dist(x1, y1, x2, y2);
      const dis = dist(x, y, x1, y1) * 0.01;

      let offset = applyFunction(frequency * dis * TWO_PI + phase + t) * amplitude;

      x += offset * (y2 - y1) / baseLen;
      y -= offset * (x2 - x1) / baseLen;

      if (currentFunction === 0 || currentFunction === 2) {
        curveVertex(x, y);
      } else {
        vertex(x, y);
      }
    }
    endShape();
  }

  function applyFunction(tt) {
    switch (currentFunction) {
      case 0: return sin(tt);
      case 1: return (tt % TWO_PI < PI) ? 1 : -1;
      case 2: return asin(sin(tt)) * 2 / PI;
      case 3: return (tt % TWO_PI) / PI - 1;
      default: return sin(tt);
    }
  }

  // =============== 参数映射（对应你的 updateParameters） ===============
  function updateParameters() {
    scl = map(sliders[0].val, 0, 1, 0.5, 3);
    strokeW = map(sliders[1].val, 0, 1, 0.5, 20);
    amplitude = map(sliders[2].val, 0, 1, 0, maxAmp);
    frequency = map(sliders[3].val, 0, 1, 0.1, 5);
    phase = map(sliders[4].val, 0, 1, 0, TWO_PI);
    animationSpeed = map(sliders[5].val, 0, 1, 0, 0.1);
  }

  // =============== 右下角函数显示（对应你的 drawFunctionDisplay） ===============
  function drawFunctionDisplay() {
    const displayWidth = 250;
    const displayHeight = 250;
    const margin = 50;

    push();
    stroke(0);
    strokeWeight(3);
    translate(width - displayWidth / 2 - margin, height - displayHeight / 2 - margin);

    // axes
    line(-displayWidth / 2, 0, displayWidth / 2, 0);
    line(0, -displayHeight / 2, 0, displayHeight / 2);

    // arrows
    fill(0);
    noStroke();
    triangle(-5, -displayHeight / 2, 5, -displayHeight / 2, 0, -displayHeight / 2 - 15);
    triangle(displayWidth / 2 + 15, 0, displayWidth / 2, -5, displayWidth / 2, 5);

    // labels
    fill(0);
    textSize(15);
    textAlign(LEFT, TOP);
    text("y", 10, -displayHeight / 2 + 8);
    textAlign(LEFT, CENTER);
    text("x", displayWidth / 2 - 10, 18);

    // title
    textAlign(CENTER, BOTTOM);
    textSize(18);
    text(functionNames[currentFunction] + " Function", 0, -displayHeight / 2 - 18);
    pop();

    // wave
    const picCol = color(140);
    stroke(picCol);
    noFill();
    strokeWeight(3);

    beginShape();
    for (let x = 0; x < displayWidth; x += 2) {
      const amp = map(amplitude, 0, maxAmp, 0, displayHeight / 2);
      const y = applyFunction(frequency * x * 0.02 + phase + t) * amp;
      vertex(width - displayWidth - margin + x, height - displayHeight / 2 - margin - y);
    }
    endShape();
  }

  // =============== 颜色面板（替代 ColorWheel，稳定且好看） ===============
  function buildHueGraphic() {
    hueGraphic = createGraphics(HUE_BAR.w, HUE_BAR.h);
    hueGraphic.colorMode(HSB, 360, 100, 100);
    hueGraphic.noStroke();
    hueGraphic.loadPixels();
    for (let y = 0; y < HUE_BAR.h; y++) {
      const h = map(y, 0, HUE_BAR.h - 1, 0, 360);
      const c = hueGraphic.color(h, 100, 100);
      for (let x = 0; x < HUE_BAR.w; x++) {
        const idx = (y * HUE_BAR.w + x) * 4;
        hueGraphic.pixels[idx] = red(c);
        hueGraphic.pixels[idx + 1] = green(c);
        hueGraphic.pixels[idx + 2] = blue(c);
        hueGraphic.pixels[idx + 3] = 255;
      }
    }
    hueGraphic.updatePixels();
  }

  function buildSBGraphic() {
    sbGraphic = createGraphics(SB_PANEL.w, SB_PANEL.h);
    sbGraphic.colorMode(HSB, 360, 100, 100);
    sbGraphic.noStroke();
    sbGraphic.loadPixels();
    for (let y = 0; y < SB_PANEL.h; y++) {
      for (let x = 0; x < SB_PANEL.w; x++) {
        const s = map(x, 0, SB_PANEL.w - 1, 0, 100);
        const b = map(y, 0, SB_PANEL.h - 1, 100, 0);
        const c = sbGraphic.color(hueVal, s, b);
        const idx = (y * SB_PANEL.w + x) * 4;
        sbGraphic.pixels[idx] = red(c);
        sbGraphic.pixels[idx + 1] = green(c);
        sbGraphic.pixels[idx + 2] = blue(c);
        sbGraphic.pixels[idx + 3] = 255;
      }
    }
    sbGraphic.updatePixels();
  }

  function updateCurrentColorFromHSV(rebuildSB) {
    push();
    colorMode(HSB, 360, 100, 100);
    currentColor = color(hueVal, satVal, briVal);
    pop();
    if (rebuildSB) buildSBGraphic();
  }

  function drawColorPanel() {
    // 面板背景
    noStroke();
    fill(40);
    rect(8, 8, cw - 16, 184, 14);

    // 贴图
    imageMode(CORNER);
    image(sbGraphic, SB_PANEL.x, SB_PANEL.y);
    image(hueGraphic, HUE_BAR.x, HUE_BAR.y);

    // SB 游标
    const sx = map(satVal, 0, 100, SB_PANEL.x, SB_PANEL.x + SB_PANEL.w);
    const sy = map(briVal, 100, 0, SB_PANEL.y, SB_PANEL.y + SB_PANEL.h);
    stroke(255);
    strokeWeight(2);
    noFill();
    circle(sx, sy, 12);

    // Hue 游标
    const hy = map(hueVal, 0, 360, HUE_BAR.y, HUE_BAR.y + HUE_BAR.h);
    stroke(255);
    strokeWeight(2);
    line(HUE_BAR.x - 4, hy, HUE_BAR.x, hy);
    line(HUE_BAR.x + HUE_BAR.w, hy, HUE_BAR.x + HUE_BAR.w + 4, hy);

    // 当前颜色小块
    noStroke();
    fill(currentColor);
    rect(10, 190, cw - 20, 34, 10);
  }

  function handleColorClick() {
    // SB
    if (mouseX >= SB_PANEL.x && mouseX <= SB_PANEL.x + SB_PANEL.w &&
        mouseY >= SB_PANEL.y && mouseY <= SB_PANEL.y + SB_PANEL.h) {

      const sx = constrain(mouseX, SB_PANEL.x, SB_PANEL.x + SB_PANEL.w);
      const sy = constrain(mouseY, SB_PANEL.y, SB_PANEL.y + SB_PANEL.h);

      satVal = map(sx, SB_PANEL.x, SB_PANEL.x + SB_PANEL.w, 0, 100);
      briVal = map(sy, SB_PANEL.y, SB_PANEL.y + SB_PANEL.h, 100, 0);

      updateCurrentColorFromHSV(false);
      return true;
    }

    // Hue
    if (mouseX >= HUE_BAR.x && mouseX <= HUE_BAR.x + HUE_BAR.w &&
        mouseY >= HUE_BAR.y && mouseY <= HUE_BAR.y + HUE_BAR.h) {

      const hy = constrain(mouseY, HUE_BAR.y, HUE_BAR.y + HUE_BAR.h);
      hueVal = map(hy, HUE_BAR.y, HUE_BAR.y + HUE_BAR.h, 0, 360);

      updateCurrentColorFromHSV(true);
      return true;
    }
    return false;
  }

  // =============== 交互：鼠标点击 ===============
  function mousePressed() {
    // 左侧颜色面板
    if (handleColorClick()) return;

    // sliders
    for (let s of sliders) s.click();

    // buttons
    for (let b of capButtons) {
      if (b.hover()) {
        handleButtonPress(b.str);
      }
    }
  }

  function mouseReleased() {
    for (let s of sliders) s.state = false;
  }

  // =============== 按钮逻辑（对应你的 handleButtonPress） ===============
  function handleButtonPress(label) {
    switch (label) {
      case "Save":
        saveCanvas("MathA", "png");
        break;
      case "Toggle Animation":
        isAnimating = !isAnimating;
        break;
      case "Reset":
        resetToDefaults();
        break;
      default:
        for (let i = 0; i < functionNames.length; i++) {
          if (label === functionNames[i]) {
            currentFunction = i;
            break;
          }
        }
        break;
    }
  }

  function resetToDefaults() {
    currentFunction = 0;
    isAnimating = true;
    t = 0;

    // 重置 sliders 到 0.5
    for (let i = 0; i < sliders.length; i++) {
      sliders[i].val = 0.5;
      sliders[i].state = false;
    }

    // 重置颜色（可按你喜欢改）
    hueVal = 220;
    satVal = 100;
    briVal = 80;
    updateCurrentColorFromHSV(true);
  }
</script>
</body>
</html>
