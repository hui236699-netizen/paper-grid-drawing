<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Font Path Method</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0f1013;
      overflow: hidden;
      height: 100%;
      width: 100%;
      touch-action: none; /* ✅ 防止移动端滚动/缩放干扰 */
    }
    canvas {
      display: block;
      position: fixed;
      left: 0;
      top: 0;
      touch-action: none;
    }

    /* ✅ 返回按钮（右上角 / 英文 / 灰底黑字） */
    .backBtn{
      position: fixed;
      right: 16px;
      top: 16px;
      z-index: 9999;
      padding: 10px 14px;
      border-radius: 999px;

      background: #DBDBDB;
      color: #000;
      border: 1px solid rgba(0,0,0,0.12);

      font-size: 13px;
      font-weight: 700;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .backBtn:hover{ background: #CFCFCF; }
    .backBtn:active{ transform: translateY(1px); }

    /* 输入框：固定在左侧栏里 */
    .glyphInput {
      position: fixed;
      background: #3A393D;
      color: #fff;
      border: 0;
      outline: none;
      border-radius: 18px;
      padding: 8px 10px;
      font-size: 14px;
      box-sizing: border-box;
      height: 36px;
      z-index: 10;
    }
    .glyphInput::placeholder{
      color: rgba(255,255,255,0.45);
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>
<body>

  <!-- ✅ 右上角返回按钮 -->
  <button class="backBtn" id="backBtn" type="button" aria-label="Back to Home">Back</button>

<script>
/* ✅ 返回逻辑：优先回到 index.html；否则用浏览器返回 */
document.getElementById("backBtn").addEventListener("click", () => {
  // 如果你的首页文件名不是 index.html，把下面这行改成你的实际首页
  const home = "index.html";
  try {
    // 在 GitHub Pages / Vercel 都稳定：直接跳首页
    window.location.href = home;
  } catch (e) {
    history.back();
  }
});

/* =================== 统一圆角（所有按钮同一套） =================== */
const BTN_R = 18;

/* =================== 字体（仅用于 UI 文本） =================== */
const FONT_PATH = "assets/fonts/ABCFavoritHebrewBoldVariable-Trial.ttf";
let uiFont = null;
let fontLoaded = false;

/* =================== 左侧操作栏（响应式） =================== */
let cw = 240;                // computeLayout() 动态更新
const COLOR_PANEL_H = 190;
let showGrid = true;

/* =================== 你的参数（保留逻辑） =================== */
let maxAmp = 50;
let t = 0;

let scaleVal = 1.0;
let strokeW = 2;
let amplitude = 10;
let frequency = 1;

// phase 逻辑保留（不做滑块 UI）
let phase = 0;

let isAnimating = true;
let animationSpeed = 0.02;

let currentFunction = 0;
const functionNames = ["Sin", "Square", "Triangle", "Sawtooth"];

/* =================== 字母输入：画面默认 X，输入框默认 placeholder =================== */
let glyphInput;
let glyphChar = "X";

/* =================== 颜色模块（✅色盘 + recent） =================== */
let hue = 0;
let sat = 0;
let bri = 0; // 默认黑
let currentColor;

let COLOR_MAIN = null;
let COLOR_HUE  = null;

let sbGraphic, hueGraphic;

// recent：动态居中 + 轻微右移
let RECENT_RECTS = [];
const defaultRecentHex = ["#000000", "#482BCC", "#FF04A5", "#FFE900", "#8CE255"];
let recentColors = [];

// 你要“往右一点点”
const RECENT_BIAS_X = 6;

/* ✅ 新增：颜色拖拽（SB/Hue） */
let isColorDragging = false;
let colorDragMode = null; // "sb" | "hue"

/* =================== 功能按钮（只保留 Pause / Save） =================== */
let pauseButton, saveButton;
let FUNC_RECTS = {};

/* =================== Randomize 按钮（更大区域） =================== */
let randomizeButton;

/* =================== 5个滑块 =================== */
const sliderName = ["Scale", "Stroke Weight", "Amplitude", "Frequency", "Animation Speed"];
let sliders = [];

/* =================== 波形按钮（左侧下方 2×2） =================== */
let waveButtons = [];

/* =================== 控件整体下移 + 底部留白（不影响色盘位置） =================== */
const CONTROLS_SHIFT_Y = 18;
const BOTTOM_PAD = 24;

/* =================== 小工具 =================== */
function clamp(v, lo, hi) { return max(lo, min(hi, v)); }

/* ============================================================
   ✅ 新增：单线骨架字库（解决“输入啥都像X”的问题）
   ============================================================ */
const STICK_FONT = {
  "A": [
    [[-60, 110],[0,-110],[60,110]],
    [[-35, 10],[35,10]]
  ],
  "B": [
    [[-60,-110],[-60,110]],
    [[-60,-110],[30,-80],[30,-20],[-60,0]],
    [[-60,0],[30,20],[30,80],[-60,110]]
  ],
  "C": [
    [[40,-90],[0,-110],[-50,-70],[-60,0],[-50,70],[0,110],[40,90]]
  ],
  "D": [
    [[-60,-110],[-60,110]],
    [[-60,-110],[20,-95],[55,-55],[55,55],[20,95],[-60,110]]
  ],
  "E": [
    [[50,-110],[-60,-110],[-60,110],[50,110]],
    [[-60,0],[20,0]]
  ],
  "F": [
    [[-60,-110],[-60,110]],
    [[-60,-110],[55,-110]],
    [[-60,0],[25,0]]
  ],
  "G": [
    [[40,-90],[0,-110],[-50,-70],[-60,0],[-50,70],[0,110],[45,90],[45,30],[10,30]]
  ],
  "H": [
    [[-60,-110],[-60,110]],
    [[60,-110],[60,110]],
    [[-60,0],[60,0]]
  ],
  "I": [
    [[0,-110],[0,110]],
    [[-40,-110],[40,-110]],
    [[-40,110],[40,110]]
  ],
  "J": [
    [[45,-110],[-20,-110]],
    [[45,-110],[45,70],[20,110],[-20,95],[-35,70]]
  ],
  "K": [
    [[-60,-110],[-60,110]],
    [[-60,0],[60,-110]],
    [[-60,0],[60,110]]
  ],
  "L": [
    [[-60,-110],[-60,110],[55,110]]
  ],
  "M": [
    [[-60,110],[-60,-110],[0,0],[60,-110],[60,110]]
  ],
  "N": [
    [[-60,110],[-60,-110],[60,110],[60,-110]]
  ],
  "O": [
    [[0,-110],[55,-80],[70,-20],[70,20],[55,80],[0,110],[-55,80],[-70,20],[-70,-20],[-55,-80],[0,-110]]
  ],
  "P": [
    [[-60,110],[-60,-110]],
    [[-60,-110],[35,-110],[55,-85],[55,-35],[35,-10],[-60,-10]]
  ],
  "Q": [
    [[0,-110],[55,-80],[70,-20],[70,20],[55,80],[0,110],[-55,80],[-70,20],[-70,-20],[-55,-80],[0,-110]],
    [[20,60],[70,120]]
  ],
  "R": [
    [[-60,110],[-60,-110]],
    [[-60,-110],[35,-110],[55,-85],[55,-35],[35,-10],[-60,-10]],
    [[-60,-10],[60,110]]
  ],
  "S": [
    [[55,-90],[20,-110],[-30,-95],[-55,-60],[-35,-20],[35,20],[55,60],[30,95],[-20,110],[-55,90]]
  ],
  "T": [
    [[-60,-110],[60,-110]],
    [[0,-110],[0,110]]
  ],
  "U": [
    [[-60,-110],[-60,60],[-35,110],[35,110],[60,60],[60,-110]]
  ],
  "V": [
    [[-60,-110],[0,110],[60,-110]]
  ],
  "W": [
    [[-70,-110],[-35,110],[0,-30],[35,110],[70,-110]]
  ],
  "X": [
    [[-70,110],[70,-110]],
    [[70,110],[-70,-110]]
  ],
  "Y": [
    [[-60,-110],[0,0],[60,-110]],
    [[0,0],[0,110]]
  ],
  "Z": [
    [[-60,-110],[60,-110],[-60,110],[60,110]]
  ],
  "?": [
    [[-20,-60],[0,-110],[20,-60],[0,-20]],
    [[0,60],[0,90]]
  ]
};

function drawStrokeGlyph(strokes) {
  for (const strokePts of strokes) {
    if (!strokePts || strokePts.length < 2) continue;
    for (let i = 0; i < strokePts.length - 1; i++) {
      const [x1, y1] = strokePts[i];
      const [x2, y2] = strokePts[i + 1];
      drawParametricCurve(x1, y1, x2, y2);
    }
  }
}

/* =================== 布局计算 =================== */
let layout = null;

function computeLayout() {
  cw = clamp(width * 0.18, 200, 320);

  const pad = 16;
  const gap = 10;

  const hueW = clamp(cw * 0.10, 18, 30);
  const sbMaxH = clamp(height * 0.28, 170, 260);
  const sbW = cw - pad * 2 - hueW - gap;
  const sbSize = floor(clamp(min(sbW, sbMaxH), 150, sbMaxH));

  COLOR_MAIN = { x: pad, y: pad, w: sbSize, h: sbSize };
  COLOR_HUE  = { x: pad + sbSize + gap, y: pad, w: floor(hueW), h: sbSize };

  rebuildRecentRects();

  const btnGapX = 12;
  const btnH = clamp(height * 0.035, 28, 38);
  const btnW = (cw - pad * 2 - btnGapX) / 2;

  const recentBottom = RECENT_RECTS.length
    ? (RECENT_RECTS[0].y + RECENT_RECTS[0].h)
    : (COLOR_MAIN.y + COLOR_MAIN.h + 28);

  const btnRowY_base = recentBottom + 18;

  FUNC_RECTS = {
    pause: { x: pad, y: btnRowY_base, w: btnW, h: btnH },
    save:  { x: pad + btnW + btnGapX, y: btnRowY_base, w: btnW, h: btnH }
  };

  const inputY_base = btnRowY_base + btnH + 18;
  const inputH = 36;
  const inputW = cw - pad * 2;

  const randomY_base = inputY_base + inputH + 18;
  const randomH = clamp(btnH * 1.35, 42, 56);
  const randomRect_base = { x: pad, y: randomY_base, w: cw - pad * 2, h: randomH };

  const sliderH = 34;
  const sliderGap = 48;
  const firstSliderY_base = randomY_base + randomH + 18;

  const waveColGap = 12;
  const waveRowGap = 12;
  const waveW = (cw - pad * 2 - waveColGap) / 2;
  const waveH = btnH;

  const waveTop_base = firstSliderY_base + 5 * sliderGap + 18;
  const waveLastBottom_base = waveTop_base + (2 * waveH + waveRowGap);

  const maxShiftAllowed = (height - BOTTOM_PAD) - waveLastBottom_base;
  const shiftY = max(0, min(CONTROLS_SHIFT_Y, maxShiftAllowed));

  FUNC_RECTS.pause.y += shiftY;
  FUNC_RECTS.save.y  += shiftY;

  layout = {
    pad,
    btnH, btnW,
    inputX: pad,
    inputY: inputY_base + shiftY,
    inputW,
    inputH,
    randomRect: { x: randomRect_base.x, y: randomRect_base.y + shiftY, w: randomRect_base.w, h: randomRect_base.h },
    firstSliderY: firstSliderY_base + shiftY,
    sliderGap,
    sliderH,
    waveTop: waveTop_base + shiftY,
    waveW,
    waveH,
    waveColGap,
    waveRowGap
  };
}

function rebuildRecentRects() {
  const RECENT_COUNT = 5;
  const RECENT_GAP = 10;
  const RECENT_SIZE = 28;

  const totalW = RECENT_COUNT * RECENT_SIZE + (RECENT_COUNT - 1) * RECENT_GAP;
  const startX = (cw - totalW) / 2 + RECENT_BIAS_X;

  const y = COLOR_MAIN.y + COLOR_MAIN.h + 18;

  RECENT_RECTS = [];
  for (let i = 0; i < RECENT_COUNT; i++) {
    RECENT_RECTS.push({
      x: startX + i * (RECENT_SIZE + RECENT_GAP),
      y,
      w: RECENT_SIZE,
      h: RECENT_SIZE
    });
  }
}

/* =================== setup =================== */
function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);

  currentColor = color(0);
  recentColors = defaultRecentHex.map(h => color(h));

  computeLayout();
  buildHueGraphic();
  buildSBGraphic();

  pauseButton = rectToCapButton(FUNC_RECTS.pause, "Pause");
  saveButton  = rectToCapButton(FUNC_RECTS.save,  "Save");

  glyphChar = "X";
  glyphInput = createInput("");
  glyphInput.addClass("glyphInput");
  glyphInput.attribute("maxlength", "2");
  glyphInput.attribute("placeholder", "Try a letter");
  placeGlyphInput();

  glyphInput.input(() => {
    let v = glyphInput.value();
    if (v.length === 0) { glyphChar = "X"; return; }
    if (v.length > 2) { v = v.slice(0, 2); glyphInput.value(v); }
    glyphChar = v;
  });

  glyphInput.elt.addEventListener("blur", () => {
    if (!glyphInput.value() || glyphInput.value().length === 0) glyphChar = "X";
  });

  randomizeButton = new CapButton(
    layout.randomRect.x + layout.randomRect.w/2,
    layout.randomRect.y + layout.randomRect.h/2,
    layout.randomRect.w,
    layout.randomRect.h,
    "Randomize",
    true
  );

  sliders = [];
  for (let i = 0; i < 5; i++) {
    const y = layout.firstSliderY + i * layout.sliderGap;
    sliders.push(new Slider(cw/2, y + layout.sliderH/2, 200, layout.sliderH, sliderName[i], 0.5));
  }

  waveButtons = [];
  const names = ["Sin","Square","Triangle","Sawtooth"];
  for (let r = 0; r < 2; r++) {
    for (let c = 0; c < 2; c++) {
      const idx = r*2 + c;
      const x = layout.pad + c * (layout.waveW + layout.waveColGap) + layout.waveW/2;
      const y = layout.waveTop + r * (layout.waveH + layout.waveRowGap) + layout.waveH/2;
      waveButtons.push(new CapButton(x, y, layout.waveW, layout.waveH, names[idx], false));
    }
  }
  setWaveSelected(0);

  tryLoadUIFont();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  computeLayout();
  buildHueGraphic();
  buildSBGraphic();

  pauseButton = rectToCapButton(FUNC_RECTS.pause, isAnimating ? "Pause" : "Play");
  saveButton  = rectToCapButton(FUNC_RECTS.save,  "Save");

  randomizeButton = new CapButton(
    layout.randomRect.x + layout.randomRect.w/2,
    layout.randomRect.y + layout.randomRect.h/2,
    layout.randomRect.w,
    layout.randomRect.h,
    "Randomize",
    true
  );

  for (let i = 0; i < sliders.length; i++) {
    const y = layout.firstSliderY + i * layout.sliderGap;
    sliders[i].x = cw/2;
    sliders[i].y = y + layout.sliderH/2;
    sliders[i].h = layout.sliderH;
  }

  const names = ["Sin","Square","Triangle","Sawtooth"];
  for (let r = 0; r < 2; r++) {
    for (let c = 0; c < 2; c++) {
      const idx = r*2 + c;
      const x = layout.pad + c * (layout.waveW + layout.waveColGap) + layout.waveW/2;
      const y = layout.waveTop + r * (layout.waveH + layout.waveRowGap) + layout.waveH/2;
      waveButtons[idx].x = x;
      waveButtons[idx].y = y;
      waveButtons[idx].w = layout.waveW;
      waveButtons[idx].h = layout.waveH;
      waveButtons[idx].str = names[idx];
    }
  }

  placeGlyphInput();
}

/* =================== draw =================== */
function draw() {
  background(240);
  updateParameters();

  if (showGrid) drawGrid();

  push();
  translate(width / 2, height / 2);
  scale(scaleVal);
  drawGlyph(glyphChar);
  pop();

  noStroke();
  fill("#1F1E24");
  rect(0, 0, cw, height);

  drawColorPanel();
  drawRecentColors();

  pauseButton.str = isAnimating ? "Pause" : "Play";
  pauseButton.display();
  saveButton.display();

  randomizeButton.display();

  for (let s of sliders) s.run();
  for (let b of waveButtons) b.display();

  drawFunctionDisplay();

  if (isAnimating) t += animationSpeed;
}

/* =================== 输入框定位 =================== */
function placeGlyphInput() {
  if (!glyphInput) return;
  glyphInput.position(layout.inputX, layout.inputY);
  glyphInput.size(layout.inputW, layout.inputH);
}

/* =================== 网格 =================== */
function drawGrid() {
  const step = 25;
  stroke(220);
  strokeWeight(1);
  for (let x = cw; x <= width; x += step) line(x, 0, x, height);
  for (let y = 0; y <= height; y += step) line(cw, y, width, y);
}

/* =================== 字母绘制 =================== */
function drawGlyph(str) {
  stroke(currentColor);
  strokeWeight(strokeW);
  noFill();

  if (!str || str.length === 0) return;

  const chars = str.slice(0,2).split("");
  const spacing = 130;

  if (chars.length === 1) {
    drawOneGlyph(chars[0], 0);
  } else {
    drawOneGlyph(chars[0], -spacing/2);
    drawOneGlyph(chars[1],  spacing/2);
  }
}

function drawOneGlyph(ch, offsetX) {
  push();
  translate(offsetX, 0);

  const up = (ch || "").toUpperCase();

  if (up === "X") {
    drawParametricCurve(-70,  110,  70, -110);
    drawParametricCurve( 70,  110, -70, -110);
  }
  else if (up === "Y") {
    drawParametricCurve(-70, -110, 0, 0);
    drawParametricCurve( 70, -110, 0, 0);
    drawParametricCurve(0, 0, 0, 120);
  }
  else if (up === "O") {
    drawParametricCircle(0, 0, 90);
  }
  else {
    const strokes = STICK_FONT[up] || STICK_FONT["?"];
    drawStrokeGlyph(strokes);
  }

  pop();
}

function drawParametricCircle(cx, cy, r) {
  beginShape();
  for (let a = 0; a <= TWO_PI + 0.001; a += 0.03) {
    let x = cx + cos(a) * r;
    let y = cy + sin(a) * r;

    let dis = (a * r) * 0.01;
    let offset = applyFunction(frequency * dis * TWO_PI + phase + t) * amplitude;

    let nx = cos(a);
    let ny = sin(a);
    x += nx * offset * 0.15;
    y += ny * offset * 0.15;

    if (currentFunction === 0 || currentFunction === 2) curveVertex(x, y);
    else vertex(x, y);
  }
  endShape(CLOSE);
}

function drawParametricCurve(x1, y1, x2, y2) {
  beginShape();
  for (let i = 0; i <= 1.00001; i += 0.01) {
    let x = lerp(x1, x2, i);
    let y = lerp(y1, y2, i);

    let dis = dist(x, y, x1, y1) * 0.01;
    let offset = applyFunction(frequency * dis * TWO_PI + phase + t) * amplitude;

    let baseLen = dist(x1, y1, x2, y2) || 1;
    x += offset * (y2 - y1) / baseLen;
    y -= offset * (x2 - x1) / baseLen;

    if (currentFunction === 0 || currentFunction === 2) curveVertex(x, y);
    else vertex(x, y);
  }
  endShape();
}

function applyFunction(tt) {
  switch (currentFunction) {
    case 0: return sin(tt);
    case 1: return (tt % TWO_PI < PI) ? 1 : -1;
    case 2: return asin(sin(tt)) * 2 / PI;
    case 3: return (tt % TWO_PI) / PI - 1;
    default: return sin(tt);
  }
}

/* =================== 参数更新 =================== */
function updateParameters() {
  scaleVal       = map(sliders[0].val, 0, 1, 0.5, 3);
  strokeW        = map(sliders[1].val, 0, 1, 0.5, 20);
  amplitude      = map(sliders[2].val, 0, 1, 0, maxAmp);
  frequency      = map(sliders[3].val, 0, 1, 0.1, 5);
  animationSpeed = map(sliders[4].val, 0, 1, 0, 0.1);
}

/* =================== 右下角函数预览 =================== */
function drawFunctionDisplay() {
  const displayWidth = 250;
  const displayHeight = 250;
  const margin = 50;

  stroke(0);
  strokeWeight(3);

  push();
  translate(width - displayWidth / 2 - margin, height - displayHeight / 2 - margin);

  line(-displayWidth / 2, 0, displayWidth / 2, 0);
  line(0, -displayHeight / 2, 0, displayHeight / 2);

  fill(0);
  noStroke();
  textSize(15);

  triangle(-5, -displayHeight / 2, 5, -displayHeight / 2, 0, -displayHeight / 2 - 15);
  triangle(displayWidth / 2 + 15, 0, displayWidth / 2, -5, displayWidth / 2, 5);

  fill(0);
  textAlign(LEFT, TOP);
  text("y", 15, -displayHeight / 2);
  text("x", displayWidth / 2, 25);

  textSize(20);
  textAlign(CENTER, BOTTOM);
  text(functionNames[currentFunction] + " Function", 0, -displayHeight / 2 - 40);
  pop();

  stroke(color(140));
  noFill();
  strokeWeight(3);

  beginShape();
  for (let x = 0; x < displayWidth; x += 2) {
    let amp = map(amplitude, 0, maxAmp, 0, displayHeight / 2);
    let y = applyFunction(frequency * x * 0.02 + phase + t) * amp;
    vertex(width - displayWidth - margin + x, height - displayHeight / 2 - margin - y);
  }
  endShape();
}

/* =================== 颜色模块（色盘贴图） =================== */
function buildHueGraphic() {
  const w = max(1, floor(COLOR_HUE.w));
  const h = max(1, floor(COLOR_HUE.h));

  hueGraphic = createGraphics(w, h);
  hueGraphic.pixelDensity(1);
  hueGraphic.colorMode(HSB, 360, 100, 100);
  hueGraphic.noStroke();
  hueGraphic.loadPixels();

  for (let y = 0; y < h; y++) {
    let hh = map(y, 0, h - 1, 0, 360);
    let c = hueGraphic.color(hh, 100, 100);
    for (let x = 0; x < w; x++) {
      let idx = (y * w + x) * 4;
      hueGraphic.pixels[idx]     = red(c);
      hueGraphic.pixels[idx + 1] = green(c);
      hueGraphic.pixels[idx + 2] = blue(c);
      hueGraphic.pixels[idx + 3] = 255;
    }
  }
  hueGraphic.updatePixels();
}

function buildSBGraphic() {
  const w = max(1, floor(COLOR_MAIN.w));
  const h = max(1, floor(COLOR_MAIN.h));

  sbGraphic = createGraphics(w, h);
  sbGraphic.pixelDensity(1);
  sbGraphic.colorMode(HSB, 360, 100, 100);
  sbGraphic.noStroke();
  sbGraphic.loadPixels();

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let sVal = map(x, 0, w - 1, 0, 100);
      let bVal = map(y, 0, h - 1, 100, 0);
      let c = sbGraphic.color(hue, sVal, bVal);
      let idx = (y * w + x) * 4;
      sbGraphic.pixels[idx]     = red(c);
      sbGraphic.pixels[idx + 1] = green(c);
      sbGraphic.pixels[idx + 2] = blue(c);
      sbGraphic.pixels[idx + 3] = 255;
    }
  }
  sbGraphic.updatePixels();
}

function drawColorPanel() {
  noTint();

  noStroke();
  fill(20,20,24);
  rect(8, 8, cw-16, COLOR_PANEL_H, BTN_R);

  imageMode(CORNER);
  image(sbGraphic, COLOR_MAIN.x, COLOR_MAIN.y, COLOR_MAIN.w, COLOR_MAIN.h);
  image(hueGraphic, COLOR_HUE.x, COLOR_HUE.y, COLOR_HUE.w, COLOR_HUE.h);

  let huePosY = map(hue, 0, 360, 0, COLOR_HUE.h);
  stroke(255);
  strokeWeight(2);
  let hx = COLOR_HUE.x;
  let hy = COLOR_HUE.y + huePosY;
  line(hx - 4, hy, hx, hy);
  line(hx + COLOR_HUE.w, hy, hx + COLOR_HUE.w + 4, hy);

  let sx = map(sat, 0, 100, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
  let sy = map(bri, 100, 0, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);
  noFill();
  stroke(255);
  strokeWeight(2);
  circle(sx, sy, 10);
}

function drawRecentColors() {
  for (let i = 0; i < RECENT_RECTS.length; i++) {
    const r = RECENT_RECTS[i];
    stroke(40);
    strokeWeight(1);
    fill(recentColors[i] || color(0));
    rect(r.x, r.y, r.w, r.h, 6);

    if (recentColors[i] && colorsEqual(recentColors[i], currentColor)) {
      noFill();
      stroke(255);
      strokeWeight(2);
      rect(r.x - 3, r.y - 3, r.w + 6, r.h + 6, 8);
    }
  }
}

function handleColorPress() {
  if (mouseX >= COLOR_MAIN.x && mouseX <= COLOR_MAIN.x + COLOR_MAIN.w &&
      mouseY >= COLOR_MAIN.y && mouseY <= COLOR_MAIN.y + COLOR_MAIN.h) {
    isColorDragging = true;
    colorDragMode = "sb";
    updateColorByMouse();
    return true;
  }
  if (mouseX >= COLOR_HUE.x && mouseX <= COLOR_HUE.x + COLOR_HUE.w &&
      mouseY >= COLOR_HUE.y && mouseY <= COLOR_HUE.y + COLOR_HUE.h) {
    isColorDragging = true;
    colorDragMode = "hue";
    updateColorByMouse();
    return true;
  }
  for (let i = 0; i < RECENT_RECTS.length; i++) {
    const r = RECENT_RECTS[i];
    if (mouseX >= r.x && mouseX <= r.x + r.w &&
        mouseY >= r.y && mouseY <= r.y + r.h) {
      if (recentColors[i]) {
        currentColor = color(recentColors[i]);
        addRecentColor(currentColor);
      }
      return true;
    }
  }
  return false;
}

function updateColorByMouse() {
  if (colorDragMode === "sb") {
    let sx = constrain(mouseX, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w - 1);
    let sy = constrain(mouseY, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h - 1);
    sat = map(sx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w - 1, 0, 100);
    bri = map(sy, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h - 1, 100, 0);
    updateCurrentColor(false);
    return true;
  }
  if (colorDragMode === "hue") {
    let hy = constrain(mouseY, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h - 1);
    hue = map(hy, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h - 1, 0, 360);
    buildSBGraphic();
    updateCurrentColor(false);
    return true;
  }
  return false;
}

function updateCurrentColor(addRecent = true) {
  push();
  colorMode(HSB, 360, 100, 100);
  currentColor = color(hue, sat, bri);
  pop();
  if (addRecent) addRecentColor(currentColor);
}

function addRecentColor(c) {
  let nc = color(c);
  recentColors = recentColors.filter(rc => !colorsEqual(rc, nc));
  recentColors.unshift(nc);
  if (recentColors.length > 5) recentColors.length = 5;
}

function colorsEqual(c1, c2, eps = 1) {
  return abs(red(c1) - red(c2)) <= eps &&
         abs(green(c1) - green(c2)) <= eps &&
         abs(blue(c1) - blue(c2)) <= eps;
}

/* =================== Randomize =================== */
function randomizeParams() {
  sliders[0].val = random(0.35, 0.75);
  sliders[1].val = random(0.15, 0.85);
  sliders[2].val = random(0.05, 0.95);
  sliders[3].val = random(0.10, 0.90);
  sliders[4].val = random(0.10, 0.80);

  phase = random(0, TWO_PI);
  setWaveSelected(floor(random(0, 4)));
  t = 0;
}

/* =================== 交互 =================== */
function mousePressed() {
  if (pauseButton.hover()) { isAnimating = !isAnimating; return; }
  if (saveButton.hover())  { saveCanvas("FontPath", "png"); return; }

  if (randomizeButton.hover()) { randomizeParams(); return; }

  if (handleColorPress()) return;

  for (let s of sliders) s.click();

  for (let i = 0; i < waveButtons.length; i++) {
    if (waveButtons[i].hover()) { setWaveSelected(i); return; }
  }
}

function mouseDragged() {
  if (isColorDragging) {
    updateColorByMouse();
    return;
  }
}

function mouseReleased() {
  if (isColorDragging) {
    isColorDragging = false;
    colorDragMode = null;
    addRecentColor(currentColor);
  }
  for (let s of sliders) s.state = false;
}

function setWaveSelected(idx) {
  currentFunction = idx;
  for (let i = 0; i < waveButtons.length; i++) waveButtons[i].state = (i === idx);
}

/* =================== UI：CapButton / Slider =================== */
function rectToCapButton(rect, label) {
  const cx = rect.x + rect.w / 2;
  const cy = rect.y + rect.h / 2;
  return new CapButton(cx, cy, rect.w, rect.h, label, true);
}

class CapButton {
  constructor(x, y, w, h, str, useDrawStyle=false) {
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str;
    this.state=false;
    this.useDrawStyle = useDrawStyle;
  }
  hover() {
    return (
      mouseX >= this.x - this.w / 2 &&
      mouseX <= this.x + this.w / 2 &&
      mouseY >= this.y - this.h / 2 &&
      mouseY <= this.y + this.h / 2
    );
  }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);

    if (this.useDrawStyle) {
      if (this.hover()) fill(90, 89, 93);
      else fill("#464548");
      noStroke();
      rect(0, 0, this.w, this.h, BTN_R);
    } else {
      if (this.state) fill(110,109,113);
      else if (this.hover()) fill(90, 89, 93);
      else fill("#464548");
      noStroke();
      rect(0, 0, this.w, this.h, BTN_R);
    }

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.5);
    text(this.str, 0, 0);
    pop();
  }
}

class Slider {
  constructor(cx, cy, w, h, label, val) {
    this.x = cx; this.y = cy; this.w = w; this.h = h;
    this.label = label;
    this.val = val;
    this.state = false;
  }
  hover() { return (abs(mouseX - this.x) < this.w/2 && abs(mouseY - this.y) < this.h/2); }
  click() { this.state = this.hover(); }
  drag() {
    if (!this.state) return;
    let v = map(mouseX, this.x - this.w/2, this.x + this.w/2, 0, 1);
    v = constrain(v, 0, 1);
    this.val = lerp(this.val, v, 0.12);
  }
  run() { this.drag(); this.display(); }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);
    noStroke();

    fill(this.hover() ? 110 : 85);
    rect(0, 0, this.w, this.h, BTN_R);

    let vw = map(this.val, 0, 1, 0, this.w);
    fill(this.hover() ? 160 : 120);
    rect(-this.w/2 + vw/2, 0, vw, this.h, BTN_R);

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.45);
    text(this.label, 0, 0);
    pop();
  }
}

/* =================== 字体加载（失败不影响） =================== */
function tryLoadUIFont() {
  loadFont(
    FONT_PATH,
    (f) => { uiFont = f; fontLoaded = true; },
    () => { uiFont = null; fontLoaded = false; }
  );
}
function useUIFont() {
  if (fontLoaded && uiFont) textFont(uiFont);
  else textFont("system-ui");
}
</script>
</body>
</html>
