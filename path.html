<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MathA Generator</title>
  <style>
    html, body { margin:0; padding:0; background:#0f1013; overflow:hidden; }
    canvas { display:block; margin:0 auto; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>
<body>
<script>
/* ===========================
   Canvas / Layout
   =========================== */
const CANVAS_W = 1440;
const CANVAS_H = 900;

// 左侧创作面板宽 / 右侧系统面板宽
let LW = 240;
let RW = 220;

// 中间绘制区域（作品区）
function stageX0(){ return LW; }
function stageX1(){ return width - RW; }
function stageW(){ return stageX1() - stageX0(); }

/* ===========================
   Core parameters (keep original logic)
   =========================== */
let maxAmp = 50;
let t = 0;

let scaleVal = 1.0;
let strokeW = 2;
let amplitude = 10;
let frequency = 1;

// ✅ phase 仍在逻辑里（无滑块）
let phase = 0;

let isAnimating = true;
let animationSpeed = 0.02;

let currentFunction = 0;
const functionNames = ["Sin", "Square", "Triangle", "Sawtooth"];

/* ===========================
   Font (UI text only; if fails, use system)
   =========================== */
const FONT_PATH = "assets/fonts/ABCFavoritHebrewBoldVariable-Trial.ttf";
let uiFont = null;
let fontLoaded = false;

/* ===========================
   Color Panel (SB + Hue, like your draw.html)
   =========================== */
let hueVal = 220;
let satVal = 100;
let briVal = 80;
let currentColor;

const PAD = 12;
const COLOR_PANEL_H = 190;

const COLOR_MAIN = { x: PAD, y: 52, w: LW - PAD*2 - 24, h: COLOR_PANEL_H }; // SB
const COLOR_HUE  = { x: LW - PAD - 22, y: 52, w: 22, h: COLOR_PANEL_H };    // Hue strip

let sbGraphic, hueGraphic;

/* ===========================
   UI: Sliders / Buttons
   =========================== */
// ✅ 只剩 5 个滑块（没有 Phase）
const sliderName = ["Scale", "Stroke Weight", "Amplitude", "Frequency", "Animation Speed"];
let sliders = [];

let waveButtons = [];     // 4个波形（左侧）
let exploreButtons = [];  // Randomize / Phase Step（左侧）
let systemButtons = [];   // Toggle / Reset / Save（右侧）

const PHASE_STEP = Math.PI / 6; // Phase Step 步长（想更细就改小）

/* ===========================
   setup / draw
   =========================== */
function setup(){
  createCanvas(CANVAS_W, CANVAS_H);
  pixelDensity(1);

  // color init
  updateCurrentColorFromHSV(true);

  // build color graphics
  buildHueGraphic();
  buildSBGraphic();

  // Sliders（DEFORM 区）
  const deformTitleY = COLOR_MAIN.y + COLOR_MAIN.h + 48; // “DEFORM”标题下方开始
  const sliderGap = 54;
  for (let i = 0; i < 5; i++) {
    const y = deformTitleY + 28 + i * sliderGap;
    sliders.push(new Slider(LW/2, y, LW - PAD*2, 34, sliderName[i], 0.5));
  }

  // WAVE buttons（4个）
  // 两列布局
  const waveTop = sliders[sliders.length-1].y + 70;
  const bw = (LW - PAD*2 - 10) / 2;
  const bh = 34;

  const waveNames = ["Sin", "Square", "Triangle", "Sawtooth"];
  for (let i = 0; i < 4; i++) {
    const col = i % 2;
    const row = Math.floor(i / 2);
    const x = PAD + bw/2 + col * (bw + 10);
    const y = waveTop + 28 + row * (bh + 12);
    const b = new CapButton(x, y, bw, bh, waveNames[i]);
    waveButtons.push(b);
  }
  // default wave selected
  setWaveSelected(0);

  // EXPLORE buttons（Randomize 大 + Phase Step 小）
  const exploreTop = waveTop + 28 + 2*(bh+12) + 36;
  const randBtn = new CapButton(LW/2, exploreTop + 26, LW - PAD*2, 38, "Randomize");
  const stepBtn = new CapButton(LW/2, exploreTop + 26 + 52, LW - PAD*2, 34, "Phase Step");
  exploreButtons = [randBtn, stepBtn];

  // SYSTEM buttons（右侧）
  const sysX = width - RW/2;
  const sysTop = 90;
  systemButtons = [
    new CapButton(sysX, sysTop + 0,  RW - PAD*2, 36, "Toggle Animation"),
    new CapButton(sysX, sysTop + 54, RW - PAD*2, 36, "Reset"),
    new CapButton(sysX, sysTop + 108, RW - PAD*2, 40, "Save")
  ];

  tryLoadUIFont();
}

function draw(){
  background(240);

  updateParameters();

  // ===== 中间作品区 =====
  drawStageBackground();
  drawGrid();

  push();
  translate(stageX0() + stageW()/2, height/2);
  scale(scaleVal);
  drawMathA();
  pop();

  // ===== 左侧创作面板 =====
  drawLeftPanel();

  // ===== 右侧系统面板 =====
  drawRightPanel();

  // animation
  if (isAnimating) t += animationSpeed;
}

/* ===========================
   Stage (center area)
   =========================== */
function drawStageBackground(){
  noStroke();
  fill(245);
  rect(stageX0(), 0, stageW(), height);
}

/* ===========================
   Grid (only in stage)
   =========================== */
function drawGrid(){
  stroke(220);
  strokeWeight(1);
  const step = 25;

  for (let x = stageX0(); x <= stageX1(); x += step) line(x, 0, x, height);
  for (let y = 0; y <= height; y += step) line(stageX0(), y, stageX1(), y);
}

/* ===========================
   Original MathA logic (kept)
   =========================== */
function drawMathA(){
  stroke(currentColor);
  strokeWeight(strokeW);
  noFill();

  drawParametricCurve(-50, 100, 0, -100);
  drawParametricCurve( 50, 100, 0, -100);
  drawParametricCurve(-30,  30, 30,  30);
}

function drawParametricCurve(x1, y1, x2, y2){
  beginShape();
  for (let i = 0; i <= 1.00001; i += 0.01) {
    let x = lerp(x1, x2, i);
    let y = lerp(y1, y2, i);

    // ✅ 完全保留：frequency*dis*TWO_PI + phase + t
    let dis = dist(x, y, x1, y1) * 0.01;
    let offset = applyFunction(frequency * dis * TWO_PI + phase + t) * amplitude;

    let baseLen = dist(x1, y1, x2, y2);
    x += offset * (y2 - y1) / baseLen;
    y -= offset * (x2 - x1) / baseLen;

    if (currentFunction === 0 || currentFunction === 2) curveVertex(x, y);
    else vertex(x, y);
  }
  endShape();
}

function applyFunction(tt){
  switch(currentFunction){
    case 0: return sin(tt);
    case 1: return (tt % TWO_PI < PI) ? 1 : -1;
    case 2: return asin(sin(tt)) * 2 / PI;
    case 3: return (tt % TWO_PI) / PI - 1;
    default: return sin(tt);
  }
}

/* ===========================
   Parameters (no phase slider)
   =========================== */
function updateParameters(){
  scaleVal = map(sliders[0].val, 0, 1, 0.5, 3);
  strokeW  = map(sliders[1].val, 0, 1, 0.5, 20);
  amplitude= map(sliders[2].val, 0, 1, 0, maxAmp);
  frequency= map(sliders[3].val, 0, 1, 0.1, 5);
  animationSpeed = map(sliders[4].val, 0, 1, 0, 0.1);
}

/* ===========================
   Left Panel (COLOR / DEFORM / WAVE / EXPLORE)
   =========================== */
function drawLeftPanel(){
  // panel bg
  noStroke();
  fill(31, 30, 36);
  rect(0, 0, LW, height);

  // Titles
  fill(255);
  useUIFont();
  textAlign(LEFT, CENTER);

  // COLOR
  textSize(14);
  text("COLOR", PAD, 26);

  // color panel itself
  drawColorPanel();

  // DEFORM
  textSize(14);
  text("DEFORM", PAD, COLOR_MAIN.y + COLOR_MAIN.h + 26);

  // sliders
  for (let s of sliders) s.run();

  // WAVE
  textSize(14);
  const waveTitleY = waveButtons[0].y - 42;
  text("WAVE", PAD, waveTitleY);

  for (let b of waveButtons) b.display();

  // EXPLORE
  textSize(14);
  const exploreTitleY = exploreButtons[0].y - 42;
  text("EXPLORE", PAD, exploreTitleY);

  // Explore buttons
  exploreButtons[0].display(); // Randomize
  exploreButtons[1].display(); // Phase Step

  // small hint (optional)
  textSize(11);
  fill(200, 200, 200, 180);
  text("Tips: R=randomize, P=phase step", PAD, height - 18);
}

/* ===========================
   Right Panel (SYSTEM)
   =========================== */
function drawRightPanel(){
  noStroke();
  fill(31, 30, 36);
  rect(width - RW, 0, RW, height);

  // Title
  fill(255);
  useUIFont();
  textAlign(LEFT, CENTER);
  textSize(14);
  text("SYSTEM", width - RW + PAD, 26);

  // Toggle shows state
  systemButtons[0].state = isAnimating;

  // Buttons
  for (let b of systemButtons) b.display();

  // Optional tiny status block
  fill(200, 200, 200, 180);
  textSize(12);
  textAlign(LEFT, TOP);
  const sx = width - RW + PAD;
  const sy = systemButtons[2].y + 40;
  const waveName = functionNames[currentFunction];
  text(
    "Wave: " + waveName + "\n" +
    "Animating: " + (isAnimating ? "ON" : "OFF"),
    sx, sy
  );
}

/* ===========================
   Randomize / Phase Step actions
   =========================== */
function randomizeParams(){
  // 只随机“造型参数”+phase，不动颜色，避免你选色被打断
  sliders[0].val = random(0.20, 0.75);  // scale
  sliders[1].val = random(0.05, 0.55);  // stroke
  sliders[2].val = random(0.10, 0.85);  // amplitude
  sliders[3].val = random(0.15, 0.70);  // frequency
  sliders[4].val = random(0.05, 0.55);  // speed
  phase = random(0, TWO_PI);
}

function phaseStep(){
  phase = (phase + PHASE_STEP) % TWO_PI;
}

/* ===========================
   Mouse interaction
   =========================== */
function mousePressed(){
  // 1) Color panel
  if (handleColorClick()) return;

  // 2) Sliders (left)
  for (let s of sliders) s.click();

  // 3) Wave buttons
  for (let i = 0; i < waveButtons.length; i++) {
    if (waveButtons[i].hover()) {
      setWaveSelected(i);
      return;
    }
  }

  // 4) Explore buttons
  if (exploreButtons[0].hover()) { randomizeParams(); return; }
  if (exploreButtons[1].hover()) { phaseStep(); return; }

  // 5) System buttons (right)
  if (systemButtons[0].hover()) { isAnimating = !isAnimating; return; }
  if (systemButtons[1].hover()) { resetToDefaults(); return; }
  if (systemButtons[2].hover()) { saveCanvas("MathA", "png"); return; }
}

function mouseReleased(){
  for (let s of sliders) s.state = false;
}

function setWaveSelected(idx){
  currentFunction = idx;
  for (let i = 0; i < waveButtons.length; i++) waveButtons[i].state = (i === idx);
}

function resetToDefaults(){
  currentFunction = 0;
  setWaveSelected(0);

  isAnimating = true;
  t = 0;

  for (let s of sliders) {
    s.val = 0.5;
    s.state = false;
  }

  hueVal = 220; satVal = 100; briVal = 80;
  updateCurrentColorFromHSV(true);

  phase = 0;
}

/* ===========================
   Keyboard shortcuts
   =========================== */
function keyPressed(){
  if (key === 'r' || key === 'R') randomizeParams();
  if (key === 'p' || key === 'P') phaseStep();

  if (key === ' ') isAnimating = !isAnimating;

  if (key === '1') setWaveSelected(0);
  if (key === '2') setWaveSelected(1);
  if (key === '3') setWaveSelected(2);
  if (key === '4') setWaveSelected(3);

  if (key === 's' || key === 'S') saveCanvas("MathA", "png");
}

/* ===========================
   Color panel rendering
   =========================== */
function buildHueGraphic(){
  hueGraphic = createGraphics(COLOR_HUE.w, COLOR_HUE.h);
  hueGraphic.colorMode(HSB, 360, 100, 100);
  hueGraphic.noStroke();
  hueGraphic.loadPixels();

  for (let y = 0; y < COLOR_HUE.h; y++) {
    let h = map(y, 0, COLOR_HUE.h - 1, 0, 360);
    let c = hueGraphic.color(h, 100, 100);
    for (let x = 0; x < COLOR_HUE.w; x++) {
      let idx = (y * COLOR_HUE.w + x) * 4;
      hueGraphic.pixels[idx]     = red(c);
      hueGraphic.pixels[idx + 1] = green(c);
      hueGraphic.pixels[idx + 2] = blue(c);
      hueGraphic.pixels[idx + 3] = 255;
    }
  }
  hueGraphic.updatePixels();
}

function buildSBGraphic(){
  sbGraphic = createGraphics(COLOR_MAIN.w, COLOR_MAIN.h);
  sbGraphic.colorMode(HSB, 360, 100, 100);
  sbGraphic.noStroke();
  sbGraphic.loadPixels();

  for (let y = 0; y < COLOR_MAIN.h; y++) {
    for (let x = 0; x < COLOR_MAIN.w; x++) {
      let sVal = map(x, 0, COLOR_MAIN.w - 1, 0, 100);
      let bVal = map(y, 0, COLOR_MAIN.h - 1, 100, 0);
      let c = sbGraphic.color(hueVal, sVal, bVal);
      let idx = (y * COLOR_MAIN.w + x) * 4;
      sbGraphic.pixels[idx]     = red(c);
      sbGraphic.pixels[idx + 1] = green(c);
      sbGraphic.pixels[idx + 2] = blue(c);
      sbGraphic.pixels[idx + 3] = 255;
    }
  }
  sbGraphic.updatePixels();
}

function updateCurrentColorFromHSV(rebuildSB){
  push();
  colorMode(HSB, 360, 100, 100);
  currentColor = color(hueVal, satVal, briVal);
  pop();
  if (rebuildSB) buildSBGraphic();
}

function drawColorPanel(){
  imageMode(CORNER);
  image(sbGraphic, COLOR_MAIN.x, COLOR_MAIN.y);
  image(hueGraphic, COLOR_HUE.x, COLOR_HUE.y);

  // Hue marker
  let hy = map(hueVal, 0, 360, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
  stroke(255);
  strokeWeight(2);
  line(COLOR_HUE.x - 4, hy, COLOR_HUE.x, hy);
  line(COLOR_HUE.x + COLOR_HUE.w, hy, COLOR_HUE.x + COLOR_HUE.w + 4, hy);

  // Current color swatch (under panel)
  noStroke();
  fill(currentColor);
  rect(PAD, COLOR_MAIN.y + COLOR_MAIN.h + 12, LW - PAD*2, 14, 8);
}

function handleColorClick(){
  // SB
  if (mouseX >= COLOR_MAIN.x && mouseX <= COLOR_MAIN.x + COLOR_MAIN.w &&
      mouseY >= COLOR_MAIN.y && mouseY <= COLOR_MAIN.y + COLOR_MAIN.h) {

    let sx = constrain(mouseX, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
    let sy = constrain(mouseY, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);

    satVal = map(sx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w, 0, 100);
    briVal = map(sy, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h, 100, 0);

    updateCurrentColorFromHSV(false);
    return true;
  }

  // Hue
  if (mouseX >= COLOR_HUE.x && mouseX <= COLOR_HUE.x + COLOR_HUE.w &&
      mouseY >= COLOR_HUE.y && mouseY <= COLOR_HUE.y + COLOR_HUE.h) {

    let yy = constrain(mouseY, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
    hueVal = map(yy, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h, 0, 360);

    updateCurrentColorFromHSV(true);
    return true;
  }

  return false;
}

/* ===========================
   UI components: CapButton / Slider
   =========================== */
class CapButton {
  constructor(x, y, w, h, str){
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str;
    this.scl=1;
    this.gray=90;   // darker base
    this.state=false;
  }
  hover(){
    return (abs(mouseX - this.x) < this.w/2 && abs(mouseY - this.y) < this.h/2);
  }
  display(){
    push();
    rectMode(CENTER);
    translate(this.x, this.y);

    // base color
    let target = this.state ? 190 : (this.hover() ? 150 : 110);
    this.gray = lerp(this.gray, target, 0.18);
    this.scl  = lerp(this.scl, (this.hover() ? 1.04 : 1.0), 0.18);

    noStroke();
    fill(this.gray);

    push();
    scale(this.scl);
    rect(0, 0, this.w, this.h, 999);
    pop();

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.45);
    text(this.str, 0, 0);
    pop();
  }
}

class Slider {
  constructor(x, y, w, h, str, val){
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str;
    this.val=val;
    this.state=false;
  }
  hover(){
    return (abs(mouseX - this.x) < this.w/2 && abs(mouseY - this.y) < this.h/2);
  }
  click(){
    this.state = this.hover();
  }
  drag(){
    if (!this.state) return;
    let v = map(mouseX, this.x - this.w/2, this.x + this.w/2, 0, 1);
    v = constrain(v, 0, 1);
    this.val = lerp(this.val, v, 0.18);
  }
  run(){
    this.drag();
    this.display();
  }
  display(){
    push();
    rectMode(CENTER);
    translate(this.x, this.y);

    // track
    noStroke();
    fill(this.hover()? 120 : 90);
    rect(0, 0, this.w, this.h, 999);

    // fill
    let vw = map(this.val, 0, 1, 0, this.w);
    fill(this.hover()? 170 : 140);
    rect(-this.w/2 + vw/2, 0, vw, this.h, 999);

    // label
    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.42);
    text(this.str, 0, 0);

    pop();
  }
}

/* ===========================
   Font helper (safe)
   =========================== */
function tryLoadUIFont(){
  loadFont(
    FONT_PATH,
    (f) => { uiFont = f; fontLoaded = true; },
    () => { uiFont = null; fontLoaded = false; }
  );
}

function useUIFont(){
  if (fontLoaded && uiFont) textFont(uiFont);
  else textFont("system-ui");
}
</script>
</body>
</html>
