<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Font Texture Method</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0f1013;
      overflow: hidden;
      height: 100%;
      width: 100%;
    }
    canvas {
      display: block;
      position: fixed;
      left: 0;
      top: 0;
    }
    .glyphInput {
      position: fixed;
      background: #3A393D;
      color: #fff;
      border: 0;
      outline: none;
      border-radius: 18px;
      padding: 8px 10px;
      font-size: 14px;
      box-sizing: border-box;
      height: 36px;
      z-index: 10;
    }
    .glyphInput::placeholder{
      color: rgba(255,255,255,0.45);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js"></script>
</head>
<body>
<script>
/* =================== UI =================== */
const BTN_R = 18;
const FONT_PATH = "assets/fonts/ABCFavoritHebrewBoldVariable-Trial.ttf";

let uiFont = null;
let glyphFont = null;
let fontLoaded = false;

let cw = 240;
const CONTROLS_SHIFT_Y = 18;
const BOTTOM_PAD = 24;

/* =================== 输入：默认字母 O =================== */
let glyphInput;
const DEFAULT_GLYPH = "O";
let glyphChar = DEFAULT_GLYPH;

/* =================== 颜色模块（✅默认黑色） =================== */
let hue = 0, sat = 0, bri = 0;
let currentColor;

let COLOR_MAIN = null;
let COLOR_HUE  = null;
let sbGraphic, hueGraphic;

let RECENT_RECTS = [];
const defaultRecentHex = ["#000000", "#482BCC", "#FF04A5", "#FFE900", "#8CE255"];
let recentColors = [];
const RECENT_BIAS_X = 6;

/* =================== 按钮：Pause / Save + Randomize =================== */
let pauseButton, saveButton;
let randomizeButton;
let FUNC_RECTS = {};

/* =================== 4 sliders =================== */
const sliderName = ["Function Range", "Line Thickness", "Letter Size", "Animation Speed"];
let sliders = [];

/* =================== Processing 纹理参数 =================== */
let a = -2;
let daSign = +1;
let da = 0.02;

let xMin = -5, xMax = 5;
let yMin = -5, yMax = 5;

let rangeSliderValue = 5;
let thicknessSliderValue = 4;
let letterScale = 0.72;

/* ✅ 速度基础值 */
let animationSpeedSliderValue = 0.07;

let needsUpdate = true;
let isPlaying = true;

/* =================== 图层 =================== */
let functionLayer;
let letterMask;

/* =================== plot 区域：永远居中 =================== */
let basePlotSize = 500;
let plotSize = 500;
let plotX = 0, plotY = 0;

/* =================== helpers =================== */
function clamp(v, lo, hi) { return max(lo, min(hi, v)); }
function r01(lo, hi) { return random(lo, hi); }
function gauss(mu, sigma) { return mu + randomGaussian() * sigma; }

function sampleBand(bands){
  let sum = 0;
  for (const b of bands) sum += b.w;
  let r = random(sum);
  for (const b of bands) {
    r -= b.w;
    if (r <= 0) return random(b.lo, b.hi);
  }
  const last = bands[bands.length - 1];
  return random(last.lo, last.hi);
}

/* ============================================================
   ✅ 新增：艺术“坐标变形”（无 UI，Randomize 驱动）
   - 轻旋转 / 轻倾斜 / 轻拉伸
   - 让纹理气质更像“设计随机”
   ============================================================ */
let warpRot = 0;     // radians
let warpSkew = 0;    // x += k*y
let warpAspect = 1;  // x*=a, y/=a

function warpPoint(x, y){
  let xx = x * warpAspect;
  let yy = y / warpAspect;

  xx = xx + warpSkew * yy;

  const c = cos(warpRot), s = sin(warpRot);
  const rx = xx * c - yy * s;
  const ry = xx * s + yy * c;
  return { x: rx, y: ry };
}

/* =================== Randomize：记住上一次，强制差异大 =================== */
let lastRand = null; // {r,t,l,s,a,wr,ws,wa}

/* =================== preload 字体 =================== */
function preload() {
  glyphFont = loadFont(
    FONT_PATH,
    (f) => { glyphFont = f; uiFont = f; fontLoaded = true; },
    () => { glyphFont = null; uiFont = null; fontLoaded = false; }
  );
}

/* =================== layout（保持 path 的左栏节奏） =================== */
let layout = null;

function computeLayout() {
  cw = clamp(width * 0.18, 200, 320);

  const pad = 16;
  const gap = 10;

  const hueW = clamp(cw * 0.10, 18, 30);
  const sbMaxH = clamp(height * 0.28, 170, 260);
  const sbW = cw - pad * 2 - hueW - gap;
  const sbSize = floor(clamp(min(sbW, sbMaxH), 150, sbMaxH));

  COLOR_MAIN = { x: pad, y: pad, w: sbSize, h: sbSize };
  COLOR_HUE  = { x: pad + sbSize + gap, y: pad, w: floor(hueW), h: sbSize };

  rebuildRecentRects();

  const btnGapX = 12;
  const btnH = clamp(height * 0.035, 28, 38);
  const btnW = (cw - pad * 2 - btnGapX) / 2;

  const recentBottom = RECENT_RECTS.length
    ? (RECENT_RECTS[0].y + RECENT_RECTS[0].h)
    : (COLOR_MAIN.y + COLOR_MAIN.h + 28);

  const btnRowY_base = recentBottom + 18;

  FUNC_RECTS = {
    pause: { x: pad, y: btnRowY_base, w: btnW, h: btnH },
    save:  { x: pad + btnW + btnGapX, y: btnRowY_base, w: btnW, h: btnH }
  };

  const inputY_base = btnRowY_base + btnH + 18;
  const inputH = 36;
  const inputW = cw - pad * 2;

  const randomY_base = inputY_base + inputH + 18;
  const randomH = clamp(btnH * 1.35, 42, 56);
  const randomRect_base = { x: pad, y: randomY_base, w: cw - pad * 2, h: randomH };

  const sliderH = 34;
  const sliderGap = 48;
  const firstSliderY_base = randomY_base + randomH + 18;

  const lastBottom_base = firstSliderY_base + 4 * sliderGap + sliderH;
  const maxShiftAllowed = (height - BOTTOM_PAD) - lastBottom_base;
  const shiftY = max(0, min(CONTROLS_SHIFT_Y, maxShiftAllowed));

  FUNC_RECTS.pause.y += shiftY;
  FUNC_RECTS.save.y  += shiftY;

  layout = {
    pad,
    btnH, btnW,
    inputX: pad,
    inputY: inputY_base + shiftY,
    inputW,
    inputH,
    randomRect: { x: randomRect_base.x, y: randomRect_base.y + shiftY, w: randomRect_base.w, h: randomRect_base.h },
    firstSliderY: firstSliderY_base + shiftY,
    sliderGap,
    sliderH
  };
}

function rebuildRecentRects() {
  const RECENT_COUNT = 5;
  const RECENT_GAP = 10;
  const RECENT_SIZE = 28;

  const totalW = RECENT_COUNT * RECENT_SIZE + (RECENT_COUNT - 1) * RECENT_GAP;
  const startX = (cw - totalW) / 2 + RECENT_BIAS_X;
  const y = COLOR_MAIN.y + COLOR_MAIN.h + 18;

  RECENT_RECTS = [];
  for (let i = 0; i < RECENT_COUNT; i++) {
    RECENT_RECTS.push({
      x: startX + i * (RECENT_SIZE + RECENT_GAP),
      y,
      w: RECENT_SIZE,
      h: RECENT_SIZE
    });
  }
}

/* =================== setup =================== */
function setup() {
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1);
  frameRate(60);

  functionLayer = createGraphics(windowWidth, windowHeight);
  functionLayer.pixelDensity(1);

  letterMask = createGraphics(windowWidth, windowHeight);
  letterMask.pixelDensity(1);

  // ✅ 默认 currentColor = 黑色；recent 也初始化
  recentColors = defaultRecentHex.map(h => color(h));
  updateCurrentColor(false);

  computeLayout();
  buildHueGraphic();
  buildSBGraphic();

  pauseButton = rectToCapButton(FUNC_RECTS.pause, "Pause");
  saveButton  = rectToCapButton(FUNC_RECTS.save,  "Save");

  // 输入框：默认空，但画面默认显示 O
  glyphChar = DEFAULT_GLYPH;
  glyphInput = createInput("");
  glyphInput.addClass("glyphInput");
  glyphInput.attribute("maxlength", "2");
  glyphInput.attribute("placeholder", "Try a letter");
  placeGlyphInput();

  glyphInput.input(() => {
    let v = glyphInput.value();
    if (v.length === 0) { glyphChar = DEFAULT_GLYPH; needsUpdate = true; return; }
    if (v.length > 2) { v = v.slice(0, 2); glyphInput.value(v); }
    glyphChar = v;
    needsUpdate = true;
  });

  glyphInput.elt.addEventListener("blur", () => {
    if (!glyphInput.value() || glyphInput.value().length === 0) {
      glyphChar = DEFAULT_GLYPH;
      needsUpdate = true;
    }
  });

  randomizeButton = new CapButton(
    layout.randomRect.x + layout.randomRect.w/2,
    layout.randomRect.y + layout.randomRect.h/2,
    layout.randomRect.w,
    layout.randomRect.h,
    "Randomize",
    true
  );

  // sliders
  sliders = [];
  for (let i = 0; i < 4; i++) {
    const y = layout.firstSliderY + i * layout.sliderGap;
    sliders.push(new Slider(cw/2, y + layout.sliderH/2, 200, layout.sliderH, sliderName[i], 0.5));
  }

  sliders[0].val = 0.75;
  sliders[1].val = 0.65;
  sliders[2].val = 0.55;
  sliders[3].val = 0.74;

  needsUpdate = true;
}

/* =================== resize =================== */
function windowResized() {
  resizeCanvas(windowWidth, windowHeight);

  functionLayer = createGraphics(windowWidth, windowHeight);
  functionLayer.pixelDensity(1);

  letterMask = createGraphics(windowWidth, windowHeight);
  letterMask.pixelDensity(1);

  computeLayout();
  buildHueGraphic();
  buildSBGraphic();

  pauseButton = rectToCapButton(FUNC_RECTS.pause, isPlaying ? "Pause" : "Play");
  saveButton  = rectToCapButton(FUNC_RECTS.save,  "Save");

  randomizeButton = new CapButton(
    layout.randomRect.x + layout.randomRect.w/2,
    layout.randomRect.y + layout.randomRect.h/2,
    layout.randomRect.w,
    layout.randomRect.h,
    "Randomize",
    true
  );

  for (let i = 0; i < sliders.length; i++) {
    const y = layout.firstSliderY + i * layout.sliderGap;
    sliders[i].x = cw/2;
    sliders[i].y = y + layout.sliderH/2;
    sliders[i].h = layout.sliderH;
  }

  placeGlyphInput();
  needsUpdate = true;
}

/* =================== draw =================== */
function draw() {
  background(240);
  updateParameters();

  if (needsUpdate) {
    updateVisualization();
    needsUpdate = false;
  }

  drawGrid();

  push();
  imageMode(CENTER);
  translate(width/2, height/2);
  image(functionLayer, 0, 0);
  pop();

  displayFunctionWithAxis();

  if (isPlaying) {
    a += da;
    if (a > 3 || a < -2) {
      daSign *= -1;
      a = constrain(a, -2, 3);
      da = daSign * animationSpeedSliderValue;
    }
  }

  // 左侧栏
  noStroke();
  fill("#1F1E24");
  rect(0, 0, cw, height);

  drawColorPanel();
  drawRecentColors();

  pauseButton.str = isPlaying ? "Pause" : "Play";
  pauseButton.display();
  saveButton.display();
  randomizeButton.display();

  for (let s of sliders) s.run();

  needsUpdate = true;
}

/* =================== 网格 =================== */
function drawGrid() {
  stroke(220);
  strokeWeight(1);
  const step = 25;
  for (let x = 0; x <= width; x += step) line(x, 0, x, height);
  for (let y = 0; y <= height; y += step) line(0, y, width, y);
}

/* =================== 参数映射 =================== */
function updateParameters() {
  rangeSliderValue = map(sliders[0].val, 0, 1, 2, 10);

  /* ✅ Thickness 全局最大值调小到原来的 4/5：16 -> 12.8 */
  thicknessSliderValue = map(sliders[1].val, 0, 1, 2.0, 12.8);

  letterScale = map(sliders[2].val, 0, 1, 0.50, 1.45);

  animationSpeedSliderValue = map(sliders[3].val, 0, 1, 0.055, 0.26);

  if (isPlaying) da = daSign * animationSpeedSliderValue;
}

/* =================== 核心：plot 永远居中；并随 letterScale 扩张避免裁切 =================== */
function updateVisualization() {
  xMin = yMin = -rangeSliderValue;
  xMax = yMax = rangeSliderValue;

  const safeMax = min(width, height) - 40;
  const minPlot = 320;
  const maxPlot = 920;

  const base = min(width, height) * 0.75;
  basePlotSize = floor(clamp(base, minPlot, safeMax));

  const padFactor = 0.86;
  const grow = max(1, letterScale / padFactor);
  plotSize = floor(clamp(basePlotSize * grow, minPlot, min(maxPlot, safeMax)));

  plotX = round(width/2 - plotSize/2);
  plotY = round(height/2 - plotSize/2);

  const textSizePx = basePlotSize * letterScale;

  drawLetterMaskAtPlotCenter(plotX, plotY, plotSize, textSizePx);
  drawFunctionLayer(plotX, plotY, plotSize);
}

function calculateDifference(x, y) {
  const leftSide = sin(x*x + y*y);
  const rightSide = a * cos(x*y);
  return leftSide - rightSide;
}

function drawFunctionLayer(px0, py0, size) {
  functionLayer.clear();
  functionLayer.loadPixels();
  letterMask.loadPixels();

  const lt = thicknessSliderValue / 10.0;

  const cr = floor(red(currentColor));
  const cg = floor(green(currentColor));
  const cb = floor(blue(currentColor));

  for (let sx = 0; sx < size; sx++) {
    const xVal0 = map(sx, 0, size, xMin, xMax);
    const px = px0 + sx;
    if (px < 0 || px >= width) continue;

    for (let sy = 0; sy < size; sy++) {
      const py = py0 + sy;
      if (py < 0 || py >= height) continue;

      const yVal0 = map(sy, size, 0, yMin, yMax);

      // ✅ 艺术坐标变形
      const wp = warpPoint(xVal0, yVal0);
      const diff = calculateDifference(wp.x, wp.y);

      const idx = (py * width + px) * 4;
      const maskA = letterMask.pixels[idx + 3];

      if (maskA > 0 && abs(diff) < lt) {
        functionLayer.pixels[idx]     = cr;
        functionLayer.pixels[idx + 1] = cg;
        functionLayer.pixels[idx + 2] = cb;
        functionLayer.pixels[idx + 3] = 255;
      }
    }
  }
  functionLayer.updatePixels();
}

/* =================== 遮罩：textBounds 居中 =================== */
function drawLetterMaskAtPlotCenter(px0, py0, size, textSizePx) {
  letterMask.clear();
  letterMask.push();

  const cx = px0 + size/2;
  const cy = py0 + size/2;
  letterMask.translate(cx, cy);

  letterMask.noStroke();
  letterMask.fill(255);

  const s = (glyphChar || DEFAULT_GLYPH).toString().slice(0, 2);

  if (glyphFont && fontLoaded) {
    letterMask.textFont(glyphFont);
    letterMask.textSize(textSizePx);

    const b = glyphFont.textBounds(s, 0, 0, textSizePx);
    const tx = -(b.x + b.w/2);
    const ty = -(b.y + b.h/2);

    letterMask.textAlign(LEFT, BASELINE);
    letterMask.text(s, tx, ty);
  } else {
    letterMask.textFont("system-ui");
    letterMask.textSize(textSizePx);
    letterMask.textAlign(CENTER, CENTER);
    letterMask.text(s, 0, 0);
  }

  letterMask.pop();
}

/* =================== 右下角预览与信息（同步 warp） =================== */
function displayFunctionWithAxis() {
  const axisSize = 250;
  const margin = 50;

  const axisX = width - axisSize - margin;
  const axisY = height - axisSize - margin;

  stroke(0);
  strokeWeight(3);

  push();
  translate(width - axisSize/2 - margin, height - axisSize/2 - margin);

  line(-axisSize/2, 0, axisSize/2, 0);
  line(0, -axisSize/2, 0, axisSize/2);

  noStroke();
  fill(0);
  textSize(15);
  triangle(-5, -axisSize/2, 5, -axisSize/2, 0, -axisSize/2 - 15);
  triangle(axisSize/2 + 15, 0, axisSize/2, -5, axisSize/2, 5);

  useUIFont();
  textAlign(LEFT, TOP);
  text("y", 15, -axisSize/2 - 10);
  text("x", axisSize/2, 15);
  pop();

  const resolution = 2;
  const c1 = color(0);
  const c2 = color(0, 95);

  strokeWeight(1);
  for (let x = 0; x < axisSize; x += resolution) {
    for (let y = 0; y < axisSize; y += resolution) {
      const xVal0 = map(x, 0, axisSize, -5, 5);
      const yVal0 = map(y, axisSize, 0, -5, 5);
      const wp = warpPoint(xVal0, yVal0);
      const diff = calculateDifference(wp.x, wp.y);
      const cc = lerpColor(c1, c2, map(abs(diff), 0, 1, 0, 4.0));
      stroke(cc);
      point(axisX + x, axisY + y);
    }
  }

  noStroke();
  fill(0);
  useUIFont();
  textSize(16);
  textAlign(LEFT, TOP);
  const functionInfo =
    "Function: sin(x² + y²) = a * cos(xy)\n" +
    "a = " + nf(a, 1, 2) + "\n" +
    "Range: [-" + nf(rangeSliderValue, 1, 1) + ", " + nf(rangeSliderValue, 1, 1) + "]";
  text(functionInfo, axisX, axisY - 130);
}

/* =================== 颜色模块 =================== */
function buildHueGraphic() {
  const w = max(1, floor(COLOR_HUE.w));
  const h = max(1, floor(COLOR_HUE.h));

  hueGraphic = createGraphics(w, h);
  hueGraphic.pixelDensity(1);
  hueGraphic.colorMode(HSB, 360, 100, 100);
  hueGraphic.noStroke();
  hueGraphic.loadPixels();

  for (let y = 0; y < h; y++) {
    let hh = map(y, 0, h - 1, 0, 360);
    let c = hueGraphic.color(hh, 100, 100);
    for (let x = 0; x < w; x++) {
      let idx = (y * w + x) * 4;
      hueGraphic.pixels[idx]     = red(c);
      hueGraphic.pixels[idx + 1] = green(c);
      hueGraphic.pixels[idx + 2] = blue(c);
      hueGraphic.pixels[idx + 3] = 255;
    }
  }
  hueGraphic.updatePixels();
}

function buildSBGraphic() {
  const w = max(1, floor(COLOR_MAIN.w));
  const h = max(1, floor(COLOR_MAIN.h));

  sbGraphic = createGraphics(w, h);
  sbGraphic.pixelDensity(1);
  sbGraphic.colorMode(HSB, 360, 100, 100);
  sbGraphic.noStroke();
  sbGraphic.loadPixels();

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      let sVal = map(x, 0, w - 1, 0, 100);
      let bVal = map(y, 0, h - 1, 100, 0);
      let c = sbGraphic.color(hue, sVal, bVal);
      let idx = (y * w + x) * 4;
      sbGraphic.pixels[idx]     = red(c);
      sbGraphic.pixels[idx + 1] = green(c);
      sbGraphic.pixels[idx + 2] = blue(c);
      sbGraphic.pixels[idx + 3] = 255;
    }
  }
  sbGraphic.updatePixels();
}

function drawColorPanel() {
  noTint();
  imageMode(CORNER);
  image(sbGraphic, COLOR_MAIN.x, COLOR_MAIN.y, COLOR_MAIN.w, COLOR_MAIN.h);
  image(hueGraphic, COLOR_HUE.x, COLOR_HUE.y, COLOR_HUE.w, COLOR_HUE.h);

  let huePosY = map(hue, 0, 360, 0, COLOR_HUE.h);
  stroke(255);
  strokeWeight(2);
  let hx = COLOR_HUE.x;
  let hy = COLOR_HUE.y + huePosY;
  line(hx - 4, hy, hx, hy);
  line(hx + COLOR_HUE.w, hy, hx + COLOR_HUE.w + 4, hy);

  let sx = map(sat, 0, 100, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
  let sy = map(bri, 100, 0, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);
  noFill();
  stroke(255);
  strokeWeight(2);
  circle(sx, sy, 10);
}

function drawRecentColors() {
  for (let i = 0; i < RECENT_RECTS.length; i++) {
    const r = RECENT_RECTS[i];
    stroke(40);
    strokeWeight(1);
    fill(recentColors[i] || color(0));
    rect(r.x, r.y, r.w, r.h, 6);

    if (recentColors[i] && colorsEqual(recentColors[i], currentColor)) {
      noFill();
      stroke(255);
      strokeWeight(2);
      rect(r.x - 3, r.y - 3, r.w + 6, r.h + 6, 8);
    }
  }
}

function handleColorClick() {
  if (mouseX >= COLOR_MAIN.x && mouseX <= COLOR_MAIN.x + COLOR_MAIN.w &&
      mouseY >= COLOR_MAIN.y && mouseY <= COLOR_MAIN.y + COLOR_MAIN.h) {
    let sx = constrain(mouseX, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w);
    let sy = constrain(mouseY, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h);
    sat = map(sx, COLOR_MAIN.x, COLOR_MAIN.x + COLOR_MAIN.w, 0, 100);
    bri = map(sy, COLOR_MAIN.y, COLOR_MAIN.y + COLOR_MAIN.h, 100, 0);
    updateCurrentColor(true);
    needsUpdate = true;
    return true;
  }

  if (mouseX >= COLOR_HUE.x && mouseX <= COLOR_HUE.x + COLOR_HUE.w &&
      mouseY >= COLOR_HUE.y && mouseY <= COLOR_HUE.y + COLOR_HUE.h) {
    let hy = constrain(mouseY, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h);
    hue = map(hy, COLOR_HUE.y, COLOR_HUE.y + COLOR_HUE.h, 0, 360);
    buildSBGraphic();
    updateCurrentColor(true);
    needsUpdate = true;
    return true;
  }

  for (let i = 0; i < RECENT_RECTS.length; i++) {
    const r = RECENT_RECTS[i];
    if (mouseX >= r.x && mouseX <= r.x + r.w &&
        mouseY >= r.y && mouseY <= r.y + r.h) {
      if (recentColors[i]) {
        currentColor = color(recentColors[i]);
        addRecentColor(currentColor);
        needsUpdate = true;
      }
      return true;
    }
  }
  return false;
}

function updateCurrentColor(addRecent=true) {
  push();
  colorMode(HSB, 360, 100, 100);
  currentColor = color(hue, sat, bri);
  pop();
  if (addRecent) addRecentColor(currentColor);
}

function addRecentColor(c) {
  let nc = color(c);
  recentColors = recentColors.filter(rc => !colorsEqual(rc, nc));
  recentColors.unshift(nc);
  if (recentColors.length > 5) recentColors.length = 5;
}

function colorsEqual(c1, c2) {
  return red(c1) === red(c2) && green(c1) === green(c2) && blue(c1) === blue(c2);
}

/* ============================================================
   ✅ Randomize：更艺术（坐标变形 + 审美分布）+ 差别大
   - Range/LetterSize：负相关偏好（带噪声但不机械）
   - Warp：旋转/倾斜/拉伸（更像设计随机）
   - thickness <= 0.70；颜色不变；a 随机起点播放
   - 不够“变”就重抽
   ============================================================ */
function randomizeParams() {
  const propose = () => {
    // Range：仍然偏“极端好看”，但给一点中间态（更自然）
    const rVal = sampleBand([
      { w: 0.44, lo: 0.06, hi: 0.22 },
      { w: 0.12, lo: 0.32, hi: 0.62 },
      { w: 0.44, lo: 0.78, hi: 0.98 }
    ]);

    // Letter：负相关 + 非线性（更有“设计”张力）
    const gamma = random(0.70, 1.35);
    let lBase = pow(1.0 - rVal, gamma);
    let lVal = gauss(lBase, 0.10);
    lVal = clamp(lVal, 0.25, 0.98);

    // Thickness：根据风格（稠密偏中粗、稀疏偏细），并硬性 <= 0.70
    let tVal;
    if (rVal < 0.28) {
      tVal = sampleBand([
        { w: 0.60, lo: 0.28, hi: 0.52 },
        { w: 0.40, lo: 0.52, hi: 0.70 }
      ]);
    } else if (rVal > 0.72) {
      tVal = sampleBand([
        { w: 0.70, lo: 0.08, hi: 0.30 },
        { w: 0.30, lo: 0.30, hi: 0.45 }
      ]);
    } else {
      tVal = sampleBand([
        { w: 0.60, lo: 0.18, hi: 0.40 },
        { w: 0.40, lo: 0.40, hi: 0.62 }
      ]);
    }
    tVal = min(tVal, 0.70);

    // Speed：偏快但不炸
    const sVal = sampleBand([
      { w: 0.25, lo: 0.66, hi: 0.78 },
      { w: 0.55, lo: 0.78, hi: 0.90 },
      { w: 0.20, lo: 0.90, hi: 0.96 }
    ]);

    // a：随机起点开始播放（不固定）
    let a0;
    if (random() < 0.50) a0 = -2 + r01(0.00, 0.85);
    else a0 =  3 - r01(0.00, 0.85);

    // Warp：跟 Range 有“气质联动”
    // - 稠密（小 range）：小旋转 + 小倾斜（更“织物/编织”）
    // - 稀疏（大 range）：旋转更大胆 + 倾斜更明显（更“飘逸/漂移”）
    const dense = (rVal < 0.30);
    const airy  = (rVal > 0.75);

    const rot = dense ? r01(-0.18, 0.18) : airy ? r01(-0.42, 0.42) : r01(-0.30, 0.30);
    const skew = dense ? r01(-0.16, 0.16) : airy ? r01(-0.30, 0.30) : r01(-0.22, 0.22);
    const aspect = dense ? r01(0.88, 1.18) : airy ? r01(0.74, 1.34) : r01(0.82, 1.26);

    return { r:rVal, l:lVal, t:tVal, s:sVal, a:a0, wr:rot, ws:skew, wa:aspect };
  };

  const distScore = (p, q) => {
    // 差异度（Range/Letter/warp 权重大一点）
    return (
      1.10 * abs(p.r - q.r) +
      1.10 * abs(p.l - q.l) +
      0.80 * abs(p.t - q.t) +
      0.70 * abs(p.s - q.s) +
      0.70 * abs(p.wr - q.wr) +
      0.60 * abs(p.ws - q.ws) +
      0.55 * abs(p.wa - q.wa) +
      0.25 * (abs(p.a - q.a) / 5.0)
    );
  };

  let cand = null;
  const tries = 12;

  for (let k = 0; k < tries; k++) {
    const p = propose();
    if (!lastRand) { cand = p; break; }

    // ✅ 阈值略抬高：保证连点两次“非常明显”
    const d = distScore(p, lastRand);
    if (d > 1.18) { cand = p; break; }
    cand = p;
  }

  // 应用 sliders
  sliders[0].val = cand.r;
  sliders[2].val = cand.l;
  sliders[1].val = cand.t;         // <= 0.70
  sliders[3].val = cand.s;

  // 应用 a + warp
  a = cand.a;
  warpRot = cand.wr;
  warpSkew = cand.ws;
  warpAspect = cand.wa;

  daSign = random([+1, -1]);
  const newSpeed = map(sliders[3].val, 0, 1, 0.055, 0.26);
  animationSpeedSliderValue = newSpeed;
  da = isPlaying ? (daSign * newSpeed) : 0;

  // ✅ 不改颜色（保持黑色 / 当前颜色）
  lastRand = cand;
  needsUpdate = true;
}

/* =================== interaction =================== */
function mousePressed() {
  if (pauseButton.hover()) {
    isPlaying = !isPlaying;
    da = isPlaying ? (daSign * animationSpeedSliderValue) : 0;
    return;
  }
  if (saveButton.hover()) {
    saveCanvas("FontTexture", "png");
    return;
  }
  if (randomizeButton.hover()) {
    randomizeParams();
    return;
  }
  if (handleColorClick()) return;

  for (let s of sliders) s.click();
}

function mouseReleased() {
  for (let s of sliders) s.state = false;
}

/* =================== input position =================== */
function placeGlyphInput() {
  if (!glyphInput) return;
  glyphInput.position(layout.inputX, layout.inputY);
  glyphInput.size(layout.inputW, layout.inputH);
}

/* =================== UI classes =================== */
function rectToCapButton(rect, label) {
  const cx = rect.x + rect.w / 2;
  const cy = rect.y + rect.h / 2;
  return new CapButton(cx, cy, rect.w, rect.h, label, true);
}

class CapButton {
  constructor(x, y, w, h, str, useDrawStyle=false) {
    this.x=x; this.y=y; this.w=w; this.h=h; this.str=str;
    this.state=false;
    this.useDrawStyle = useDrawStyle;
  }
  hover() {
    return (
      mouseX >= this.x - this.w / 2 &&
      mouseX <= this.x + this.w / 2 &&
      mouseY >= this.y - this.h / 2 &&
      mouseY <= this.y + this.h / 2
    );
  }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);

    if (this.useDrawStyle) {
      if (this.hover()) fill(90, 89, 93);
      else fill("#464548");
      noStroke();
      rect(0, 0, this.w, this.h, BTN_R);
    } else {
      if (this.state) fill(110,109,113);
      else if (this.hover()) fill(90, 89, 93);
      else fill("#464548");
      noStroke();
      rect(0, 0, this.w, this.h, BTN_R);
    }

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.5);
    text(this.str, 0, 0);
    pop();
  }
}

class Slider {
  constructor(cx, cy, w, h, label, val) {
    this.x = cx; this.y = cy; this.w = w; this.h = h;
    this.label = label;
    this.val = val;
    this.state = false;
  }
  hover() { return (abs(mouseX - this.x) < this.w/2 && abs(mouseY - this.y) < this.h/2); }
  click() { this.state = this.hover(); }
  drag() {
    if (!this.state) return;
    let v = map(mouseX, this.x - this.w/2, this.x + this.w/2, 0, 1);
    v = constrain(v, 0, 1);
    this.val = lerp(this.val, v, 0.12);
  }
  run() { this.drag(); this.display(); }
  display() {
    push();
    translate(this.x, this.y);
    rectMode(CENTER);
    noStroke();

    fill(this.hover() ? 110 : 85);
    rect(0, 0, this.w, this.h, BTN_R);

    let vw = map(this.val, 0, 1, 0, this.w);
    fill(this.hover() ? 160 : 120);
    rect(-this.w/2 + vw/2, 0, vw, this.h, BTN_R);

    fill(255);
    useUIFont();
    textAlign(CENTER, CENTER);
    textSize(this.h * 0.45);
    text(this.label, 0, 0);
    pop();
  }
}

/* =================== fonts =================== */
function useUIFont() {
  if (fontLoaded && uiFont) textFont(uiFont);
  else textFont("system-ui");
}
</script>
</body>
</html>
